\hypertarget{namespacepyneb_1_1utils_1_1chebyshev}{\section{pyneb.\-utils.\-chebyshev Namespace Reference}
\label{namespacepyneb_1_1utils_1_1chebyshev}\index{pyneb.\-utils.\-chebyshev@{pyneb.\-utils.\-chebyshev}}
}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{\-\_\-cseries\-\_\-to\-\_\-zseries}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}{\-\_\-zseries\-\_\-to\-\_\-cseries}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ac430f61f52899c1e2a276d8b76fa47d5}{\-\_\-zseries\-\_\-mul}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a9ec3445ca77071adc655bacf9299c451}{\-\_\-zseries\-\_\-div}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a82377769dc2ed2e38828ac99897ff554}{\-\_\-zseries\-\_\-der}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ac55f3063cff69831a2882a7a30b617d7}{\-\_\-zseries\-\_\-int}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_abd824b0c3e5e2cc0f9464a0986dc3819}{poly2cheb}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a0e43853c4c6b0f440005cc6b5124557e}{cheb2poly}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ab88a5c9a7faa4458231ddb2edc1aa860}{chebline}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ad3dc62fdecc545593e36509daa1c2632}{chebfromroots}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aafceea7ad9a5a18707fcf493bcf70457}{chebadd}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a2ca3ca3bac02e30625edb4c48ada7ddf}{chebsub}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a91d78fa31041dfe9ccf7bbc0891809b3}{chebmulx}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a20beb101adf242958f21dff04591e1ca}{chebmul}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a5d4faaef412d6dfe502716e8e287d727}{chebdiv}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ab647ff3aa7750a09b934b98cddd4c90d}{chebpow}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a1ed2b9248c247449584904025ec9d460}{chebder}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a233e686a07b9935c74ce1e053f0c5f5f}{chebint}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a44ae40c5b4cbdc3a230c014c834f5ce6}{chebval}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a4a53ad781fcf149c5ab6ae5d021b0950}{chebvander}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a6bb5eb95525fd0572aea52fcd2a12c6c}{chebfit}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a63ef136648aeceebc5b0a0cfce98d49a}{chebroots}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa5e7d5d318e547f5df15b55224524753}{chebpts1}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a375236ee9f8b4a3f0d7d099af19e7818}{chebpts2}
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a9cb4e1ba55fc61d6dd46d5c6f534edbc}{\-\_\-\-\_\-all\-\_\-\-\_\-}
\item 
\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a66b8c25023851573f25dc418071de82b}{chebtrim} = trimcoef
\item 
tuple \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a57e110567544748d0de429d3743d1241}{chebdomain} = np.\-array(\mbox{[}-\/1,1\mbox{]})
\item 
tuple \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ad707fa9ec865920c2d8eedf6dfedf21c}{chebzero} = np.\-array(\mbox{[}0\mbox{]})
\item 
tuple \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a26a6cedd505a161858435461e1645503}{chebone} = np.\-array(\mbox{[}1\mbox{]})
\item 
tuple \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a00f984b78341cd7920c46d1a6acacc5f}{chebx} = np.\-array(\mbox{[}0,1\mbox{]})
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Objects for dealing with Chebyshev series.

This module provides a number of objects (mostly functions) useful for
dealing with Chebyshev series, including a `Chebyshev` class that
encapsulates the usual arithmetic operations.  (General information
on how this module represents and works with such polynomials is in the
docstring for its "parent" sub-package, `numpy.polynomial`).

Constants
---------
- `chebdomain` -- Chebyshev series default domain, [-1,1].
- `chebzero` -- (Coefficients of the) Chebyshev series that evaluates
  identically to 0.
- `chebone` -- (Coefficients of the) Chebyshev series that evaluates
  identically to 1.
- `chebx` -- (Coefficients of the) Chebyshev series for the identity map,
  ``f(x) = x``.

Arithmetic
----------
- `chebadd` -- add two Chebyshev series.
- `chebsub` -- subtract one Chebyshev series from another.
- `chebmul` -- multiply two Chebyshev series.
- `chebdiv` -- divide one Chebyshev series by another.
- `chebpow` -- raise a Chebyshev series to an positive integer power
- `chebval` -- evaluate a Chebyshev series at given points.

Calculus
--------
- `chebder` -- differentiate a Chebyshev series.
- `chebint` -- integrate a Chebyshev series.

Misc Functions
--------------
- `chebfromroots` -- create a Chebyshev series with specified roots.
- `chebroots` -- find the roots of a Chebyshev series.
- `chebvander` -- Vandermonde-like matrix for Chebyshev polynomials.
- `chebfit` -- least-squares fit returning a Chebyshev series.
- `chebpts1` -- Chebyshev points of the first kind.
- `chebpts2` -- Chebyshev points of the second kind.
- `chebtrim` -- trim leading coefficients from a Chebyshev series.
- `chebline` -- Chebyshev series representing given straight line.
- `cheb2poly` -- convert a Chebyshev series to a polynomial.
- `poly2cheb` -- convert a polynomial to a Chebyshev series.

Classes
-------
- `Chebyshev` -- A Chebyshev series class.

See also
--------
`numpy.polynomial`

Notes
-----
The implementations of multiplication, division, integration, and
differentiation use the algebraic identities [1]_:

.. math ::
    T_n(x) = \\frac{z^n + z^{-n}}{2} \\\\
    z\\frac{dx}{dz} = \\frac{z - z^{-1}}{2}.

where

.. math :: x = \\frac{z + z^{-1}}{2}.

These identities allow a Chebyshev series to be expressed as a finite,
symmetric Laurent series.  In this module, this sort of Laurent series
is referred to as a "z-series."

References
----------
.. [1] A. T. Benjamin, et al., "Combinatorial Trigonometry with Chebyshev
  Polynomials," *Journal of Statistical Planning and Inference 14*, 2008
  (preprint: http://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf, pg. 4)\end{DoxyVerb}
 

\subsection{Function Documentation}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!\-\_\-cseries\-\_\-to\-\_\-zseries@{\-\_\-cseries\-\_\-to\-\_\-zseries}}
\index{\-\_\-cseries\-\_\-to\-\_\-zseries@{\-\_\-cseries\-\_\-to\-\_\-zseries}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{\-\_\-cseries\-\_\-to\-\_\-zseries}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-\_\-cseries\-\_\-to\-\_\-zseries (
\begin{DoxyParamCaption}
\item[{}]{cs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}}\label{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}
\begin{DoxyVerb}Covert Chebyshev series to z-series.

Covert a Chebyshev series to the equivalent z-series. The result is
never an empty array. The dtype of the return is the same as that of
the input. No checks are run on the arguments as this routine is for
internal use.

Parameters
----------
cs : 1-d ndarray
    Chebyshev coefficients, ordered from low to high

Returns
-------
zs : 1-d ndarray
    Odd length symmetric z-series, ordered from  low to high.\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00100}{100} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



Referenced by \hyperlink{chebyshev_8py_source_l00841}{pyneb.\-utils.\-chebyshev.\-chebder()}, \hyperlink{chebyshev_8py_source_l00725}{pyneb.\-utils.\-chebyshev.\-chebdiv()}, \hyperlink{chebyshev_8py_source_l00912}{pyneb.\-utils.\-chebyshev.\-chebint()}, \hyperlink{chebyshev_8py_source_l00676}{pyneb.\-utils.\-chebyshev.\-chebmul()}, and \hyperlink{chebyshev_8py_source_l00790}{pyneb.\-utils.\-chebyshev.\-chebpow()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00100}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{00100} 
00101 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{\_cseries\_to\_zseries}(cs) :
00102     \textcolor{stringliteral}{"""Covert Chebyshev series to z-series.}
00103 \textcolor{stringliteral}{}
00104 \textcolor{stringliteral}{    Covert a Chebyshev series to the equivalent z-series. The result is}
00105 \textcolor{stringliteral}{    never an empty array. The dtype of the return is the same as that of}
00106 \textcolor{stringliteral}{    the input. No checks are run on the arguments as this routine is for}
00107 \textcolor{stringliteral}{    internal use.}
00108 \textcolor{stringliteral}{}
00109 \textcolor{stringliteral}{    Parameters}
00110 \textcolor{stringliteral}{    ----------}
00111 \textcolor{stringliteral}{    cs : 1-d ndarray}
00112 \textcolor{stringliteral}{        Chebyshev coefficients, ordered from low to high}
00113 \textcolor{stringliteral}{}
00114 \textcolor{stringliteral}{    Returns}
00115 \textcolor{stringliteral}{    -------}
00116 \textcolor{stringliteral}{    zs : 1-d ndarray}
00117 \textcolor{stringliteral}{        Odd length symmetric z-series, ordered from  low to high.}
00118 \textcolor{stringliteral}{}
00119 \textcolor{stringliteral}{    """}
00120     n = cs.size
00121     zs = np.zeros(2*n-1, dtype=cs.dtype)
00122     zs[n-1:] = cs/2
00123     \textcolor{keywordflow}{return} zs + zs[::-1]

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a82377769dc2ed2e38828ac99897ff554}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!\-\_\-zseries\-\_\-der@{\-\_\-zseries\-\_\-der}}
\index{\-\_\-zseries\-\_\-der@{\-\_\-zseries\-\_\-der}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{\-\_\-zseries\-\_\-der}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-der (
\begin{DoxyParamCaption}
\item[{}]{zs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}}\label{namespacepyneb_1_1utils_1_1chebyshev_a82377769dc2ed2e38828ac99897ff554}
\begin{DoxyVerb}Differentiate a z-series.

The derivative is with respect to x, not z. This is achieved using the
chain rule and the value of dx/dz given in the module notes.

Parameters
----------
zs : z-series
    The z-series to differentiate.

Returns
-------
derivative : z-series
    The derivative

Notes
-----
The zseries for x (ns) has been multiplied by two in order to avoid
using floats that are incompatible with Decimal and likely other
specialized scalar types. This scaling has been compensated by
multiplying the value of zs by two also so that the two cancels in the
division.\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00240}{240} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{chebyshev_8py_source_l00174}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-div()}.



Referenced by \hyperlink{chebyshev_8py_source_l00841}{pyneb.\-utils.\-chebyshev.\-chebder()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00240}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a82377769dc2ed2e38828ac99897ff554}{00240} 
00241 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a82377769dc2ed2e38828ac99897ff554}{\_zseries\_der}(zs) :
00242     \textcolor{stringliteral}{"""Differentiate a z-series.}
00243 \textcolor{stringliteral}{}
00244 \textcolor{stringliteral}{    The derivative is with respect to x, not z. This is achieved using the}
00245 \textcolor{stringliteral}{    chain rule and the value of dx/dz given in the module notes.}
00246 \textcolor{stringliteral}{}
00247 \textcolor{stringliteral}{    Parameters}
00248 \textcolor{stringliteral}{    ----------}
00249 \textcolor{stringliteral}{    zs : z-series}
00250 \textcolor{stringliteral}{        The z-series to differentiate.}
00251 \textcolor{stringliteral}{}
00252 \textcolor{stringliteral}{    Returns}
00253 \textcolor{stringliteral}{    -------}
00254 \textcolor{stringliteral}{    derivative : z-series}
00255 \textcolor{stringliteral}{        The derivative}
00256 \textcolor{stringliteral}{}
00257 \textcolor{stringliteral}{    Notes}
00258 \textcolor{stringliteral}{    -----}
00259 \textcolor{stringliteral}{    The zseries for x (ns) has been multiplied by two in order to avoid}
00260 \textcolor{stringliteral}{    using floats that are incompatible with Decimal and likely other}
00261 \textcolor{stringliteral}{    specialized scalar types. This scaling has been compensated by}
00262 \textcolor{stringliteral}{    multiplying the value of zs by two also so that the two cancels in the}
00263 \textcolor{stringliteral}{    division.}
00264 \textcolor{stringliteral}{}
00265 \textcolor{stringliteral}{    """}
00266     n = len(zs)//2
00267     ns = np.array([-1, 0, 1], dtype=zs.dtype)
00268     zs *= np.arange(-n, n+1)*2
00269     d, r = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a9ec3445ca77071adc655bacf9299c451}{\_zseries\_div}(zs, ns)
00270     \textcolor{keywordflow}{return} d

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a9ec3445ca77071adc655bacf9299c451}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!\-\_\-zseries\-\_\-div@{\-\_\-zseries\-\_\-div}}
\index{\-\_\-zseries\-\_\-div@{\-\_\-zseries\-\_\-div}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{\-\_\-zseries\-\_\-div}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-div (
\begin{DoxyParamCaption}
\item[{}]{z1, }
\item[{}]{z2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}}\label{namespacepyneb_1_1utils_1_1chebyshev_a9ec3445ca77071adc655bacf9299c451}
\begin{DoxyVerb}Divide the first z-series by the second.

Divide `z1` by `z2` and return the quotient and remainder as z-series.
Warning: this implementation only applies when both z1 and z2 have the
same symmetry, which is sufficient for present purposes.

Parameters
----------
z1, z2 : 1-d ndarray
    The arrays must be 1-d and have the same symmetry, but this is not
    checked.

Returns
-------

(quotient, remainder) : 1-d ndarrays
    Quotient and remainder as z-series.

Notes
-----
This is not the same as polynomial division on account of the desired form
of the remainder. If symmetic/anti-symmetric z-series are denoted by S/A
then the following rules apply:

S/S -> S,S
A/A -> S,A

The restriction to types of the same symmetry could be fixed but seems like
uneeded generality. There is no natural form for the remainder in the case
where there is no symmetry.\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00174}{174} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



Referenced by \hyperlink{chebyshev_8py_source_l00240}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-der()}, and \hyperlink{chebyshev_8py_source_l00725}{pyneb.\-utils.\-chebyshev.\-chebdiv()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00174}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a9ec3445ca77071adc655bacf9299c451}{00174} 
00175 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a9ec3445ca77071adc655bacf9299c451}{\_zseries\_div}(z1, z2) :
00176     \textcolor{stringliteral}{"""Divide the first z-series by the second.}
00177 \textcolor{stringliteral}{}
00178 \textcolor{stringliteral}{    Divide `z1` by `z2` and return the quotient and remainder as z-series.}
00179 \textcolor{stringliteral}{    Warning: this implementation only applies when both z1 and z2 have the}
00180 \textcolor{stringliteral}{    same symmetry, which is sufficient for present purposes.}
00181 \textcolor{stringliteral}{}
00182 \textcolor{stringliteral}{    Parameters}
00183 \textcolor{stringliteral}{    ----------}
00184 \textcolor{stringliteral}{    z1, z2 : 1-d ndarray}
00185 \textcolor{stringliteral}{        The arrays must be 1-d and have the same symmetry, but this is not}
00186 \textcolor{stringliteral}{        checked.}
00187 \textcolor{stringliteral}{}
00188 \textcolor{stringliteral}{    Returns}
00189 \textcolor{stringliteral}{    -------}
00190 \textcolor{stringliteral}{}
00191 \textcolor{stringliteral}{    (quotient, remainder) : 1-d ndarrays}
00192 \textcolor{stringliteral}{        Quotient and remainder as z-series.}
00193 \textcolor{stringliteral}{}
00194 \textcolor{stringliteral}{    Notes}
00195 \textcolor{stringliteral}{    -----}
00196 \textcolor{stringliteral}{    This is not the same as polynomial division on account of the desired form}
00197 \textcolor{stringliteral}{    of the remainder. If symmetic/anti-symmetric z-series are denoted by S/A}
00198 \textcolor{stringliteral}{    then the following rules apply:}
00199 \textcolor{stringliteral}{}
00200 \textcolor{stringliteral}{    S/S -> S,S}
00201 \textcolor{stringliteral}{    A/A -> S,A}
00202 \textcolor{stringliteral}{}
00203 \textcolor{stringliteral}{    The restriction to types of the same symmetry could be fixed but seems like}
00204 \textcolor{stringliteral}{    uneeded generality. There is no natural form for the remainder in the case}
00205 \textcolor{stringliteral}{    where there is no symmetry.}
00206 \textcolor{stringliteral}{}
00207 \textcolor{stringliteral}{    """}
00208     z1 = z1.copy()
00209     z2 = z2.copy()
00210     len1 = len(z1)
00211     len2 = len(z2)
00212     \textcolor{keywordflow}{if} len2 == 1 :
00213         z1 /= z2
00214         \textcolor{keywordflow}{return} z1, z1[:1]*0
00215     \textcolor{keywordflow}{elif} len1 < len2 :
00216         \textcolor{keywordflow}{return} z1[:1]*0, z1
00217     \textcolor{keywordflow}{else} :
00218         dlen = len1 - len2
00219         scl = z2[0]
00220         z2 /= scl
00221         quo = np.empty(dlen + 1, dtype=z1.dtype)
00222         i = 0
00223         j = dlen
00224         \textcolor{keywordflow}{while} i < j :
00225             r = z1[i]
00226             quo[i] = z1[i]
00227             quo[dlen - i] = r
00228             tmp = r*z2
00229             z1[i:i+len2] -= tmp
00230             z1[j:j+len2] -= tmp
00231             i += 1
00232             j -= 1
00233         r = z1[i]
00234         quo[i] = r
00235         tmp = r*z2
00236         z1[i:i+len2] -= tmp
00237         quo /= scl
00238         rem = z1[i+1:i-1+len2].copy()
00239         \textcolor{keywordflow}{return} quo, rem

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_ac55f3063cff69831a2882a7a30b617d7}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!\-\_\-zseries\-\_\-int@{\-\_\-zseries\-\_\-int}}
\index{\-\_\-zseries\-\_\-int@{\-\_\-zseries\-\_\-int}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{\-\_\-zseries\-\_\-int}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-int (
\begin{DoxyParamCaption}
\item[{}]{zs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}}\label{namespacepyneb_1_1utils_1_1chebyshev_ac55f3063cff69831a2882a7a30b617d7}
\begin{DoxyVerb}Integrate a z-series.

The integral is with respect to x, not z. This is achieved by a change
of variable using dx/dz given in the module notes.

Parameters
----------
zs : z-series
    The z-series to integrate

Returns
-------
integral : z-series
    The indefinite integral

Notes
-----
The zseries for x (ns) has been multiplied by two in order to avoid
using floats that are incompatible with Decimal and likely other
specialized scalar types. This scaling has been compensated by
dividing the resulting zs by two.\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00271}{271} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{chebyshev_8py_source_l00148}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-mul()}.



Referenced by \hyperlink{chebyshev_8py_source_l00912}{pyneb.\-utils.\-chebyshev.\-chebint()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00271}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ac55f3063cff69831a2882a7a30b617d7}{00271} 
00272 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ac55f3063cff69831a2882a7a30b617d7}{\_zseries\_int}(zs) :
00273     \textcolor{stringliteral}{"""Integrate a z-series.}
00274 \textcolor{stringliteral}{}
00275 \textcolor{stringliteral}{    The integral is with respect to x, not z. This is achieved by a change}
00276 \textcolor{stringliteral}{    of variable using dx/dz given in the module notes.}
00277 \textcolor{stringliteral}{}
00278 \textcolor{stringliteral}{    Parameters}
00279 \textcolor{stringliteral}{    ----------}
00280 \textcolor{stringliteral}{    zs : z-series}
00281 \textcolor{stringliteral}{        The z-series to integrate}
00282 \textcolor{stringliteral}{}
00283 \textcolor{stringliteral}{    Returns}
00284 \textcolor{stringliteral}{    -------}
00285 \textcolor{stringliteral}{    integral : z-series}
00286 \textcolor{stringliteral}{        The indefinite integral}
00287 \textcolor{stringliteral}{}
00288 \textcolor{stringliteral}{    Notes}
00289 \textcolor{stringliteral}{    -----}
00290 \textcolor{stringliteral}{    The zseries for x (ns) has been multiplied by two in order to avoid}
00291 \textcolor{stringliteral}{    using floats that are incompatible with Decimal and likely other}
00292 \textcolor{stringliteral}{    specialized scalar types. This scaling has been compensated by}
00293 \textcolor{stringliteral}{    dividing the resulting zs by two.}
00294 \textcolor{stringliteral}{}
00295 \textcolor{stringliteral}{    """}
00296     n = 1 + len(zs)//2
00297     ns = np.array([-1, 0, 1], dtype=zs.dtype)
00298     zs = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ac430f61f52899c1e2a276d8b76fa47d5}{\_zseries\_mul}(zs, ns)
00299     div = np.arange(-n, n+1)*2
00300     zs[:n] /= div[:n]
00301     zs[n+1:] /= div[n+1:]
00302     zs[n] = 0
00303     \textcolor{keywordflow}{return} zs
00304 
00305 \textcolor{comment}{#}
00306 \textcolor{comment}{# Chebyshev series functions}
00307 \textcolor{comment}{#}
00308 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_ac430f61f52899c1e2a276d8b76fa47d5}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!\-\_\-zseries\-\_\-mul@{\-\_\-zseries\-\_\-mul}}
\index{\-\_\-zseries\-\_\-mul@{\-\_\-zseries\-\_\-mul}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{\-\_\-zseries\-\_\-mul}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-mul (
\begin{DoxyParamCaption}
\item[{}]{z1, }
\item[{}]{z2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}}\label{namespacepyneb_1_1utils_1_1chebyshev_ac430f61f52899c1e2a276d8b76fa47d5}
\begin{DoxyVerb}Multiply two z-series.

Multiply two z-series to produce a z-series.

Parameters
----------
z1, z2 : 1-d ndarray
    The arrays must be 1-d but this is not checked.

Returns
-------
product : 1-d ndarray
    The product z-series.

Notes
-----
This is simply convolution. If symmetic/anti-symmetric z-series are
denoted by S/A then the following rules apply:

S*S, A*A -> S
S*A, A*S -> A\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00148}{148} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



Referenced by \hyperlink{chebyshev_8py_source_l00271}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-int()}, and \hyperlink{chebyshev_8py_source_l00676}{pyneb.\-utils.\-chebyshev.\-chebmul()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00148}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ac430f61f52899c1e2a276d8b76fa47d5}{00148} 
00149 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ac430f61f52899c1e2a276d8b76fa47d5}{\_zseries\_mul}(z1, z2) :
00150     \textcolor{stringliteral}{"""Multiply two z-series.}
00151 \textcolor{stringliteral}{}
00152 \textcolor{stringliteral}{    Multiply two z-series to produce a z-series.}
00153 \textcolor{stringliteral}{}
00154 \textcolor{stringliteral}{    Parameters}
00155 \textcolor{stringliteral}{    ----------}
00156 \textcolor{stringliteral}{    z1, z2 : 1-d ndarray}
00157 \textcolor{stringliteral}{        The arrays must be 1-d but this is not checked.}
00158 \textcolor{stringliteral}{}
00159 \textcolor{stringliteral}{    Returns}
00160 \textcolor{stringliteral}{    -------}
00161 \textcolor{stringliteral}{    product : 1-d ndarray}
00162 \textcolor{stringliteral}{        The product z-series.}
00163 \textcolor{stringliteral}{}
00164 \textcolor{stringliteral}{    Notes}
00165 \textcolor{stringliteral}{    -----}
00166 \textcolor{stringliteral}{    This is simply convolution. If symmetic/anti-symmetric z-series are}
00167 \textcolor{stringliteral}{    denoted by S/A then the following rules apply:}
00168 \textcolor{stringliteral}{}
00169 \textcolor{stringliteral}{    S*S, A*A -> S}
00170 \textcolor{stringliteral}{    S*A, A*S -> A}
00171 \textcolor{stringliteral}{}
00172 \textcolor{stringliteral}{    """}
00173     \textcolor{keywordflow}{return} np.convolve(z1, z2)

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!\-\_\-zseries\-\_\-to\-\_\-cseries@{\-\_\-zseries\-\_\-to\-\_\-cseries}}
\index{\-\_\-zseries\-\_\-to\-\_\-cseries@{\-\_\-zseries\-\_\-to\-\_\-cseries}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{\-\_\-zseries\-\_\-to\-\_\-cseries}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-to\-\_\-cseries (
\begin{DoxyParamCaption}
\item[{}]{zs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}}\label{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}
\begin{DoxyVerb}Covert z-series to a Chebyshev series.

Covert a z series to the equivalent Chebyshev series. The result is
never an empty array. The dtype of the return is the same as that of
the input. No checks are run on the arguments as this routine is for
internal use.

Parameters
----------
zs : 1-d ndarray
    Odd length symmetric z-series, ordered from  low to high.

Returns
-------
cs : 1-d ndarray
    Chebyshev coefficients, ordered from  low to high.\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00124}{124} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



Referenced by \hyperlink{chebyshev_8py_source_l00841}{pyneb.\-utils.\-chebyshev.\-chebder()}, \hyperlink{chebyshev_8py_source_l00725}{pyneb.\-utils.\-chebyshev.\-chebdiv()}, \hyperlink{chebyshev_8py_source_l00912}{pyneb.\-utils.\-chebyshev.\-chebint()}, \hyperlink{chebyshev_8py_source_l00676}{pyneb.\-utils.\-chebyshev.\-chebmul()}, and \hyperlink{chebyshev_8py_source_l00790}{pyneb.\-utils.\-chebyshev.\-chebpow()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00124}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}{00124} 
00125 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}{\_zseries\_to\_cseries}(zs) :
00126     \textcolor{stringliteral}{"""Covert z-series to a Chebyshev series.}
00127 \textcolor{stringliteral}{}
00128 \textcolor{stringliteral}{    Covert a z series to the equivalent Chebyshev series. The result is}
00129 \textcolor{stringliteral}{    never an empty array. The dtype of the return is the same as that of}
00130 \textcolor{stringliteral}{    the input. No checks are run on the arguments as this routine is for}
00131 \textcolor{stringliteral}{    internal use.}
00132 \textcolor{stringliteral}{}
00133 \textcolor{stringliteral}{    Parameters}
00134 \textcolor{stringliteral}{    ----------}
00135 \textcolor{stringliteral}{    zs : 1-d ndarray}
00136 \textcolor{stringliteral}{        Odd length symmetric z-series, ordered from  low to high.}
00137 \textcolor{stringliteral}{}
00138 \textcolor{stringliteral}{    Returns}
00139 \textcolor{stringliteral}{    -------}
00140 \textcolor{stringliteral}{    cs : 1-d ndarray}
00141 \textcolor{stringliteral}{        Chebyshev coefficients, ordered from  low to high.}
00142 \textcolor{stringliteral}{}
00143 \textcolor{stringliteral}{    """}
00144     n = (zs.size + 1)//2
00145     cs = zs[n-1:].copy()
00146     cs[1:n] *= 2
00147     \textcolor{keywordflow}{return} cs

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a0e43853c4c6b0f440005cc6b5124557e}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!cheb2poly@{cheb2poly}}
\index{cheb2poly@{cheb2poly}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{cheb2poly}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-cheb2poly (
\begin{DoxyParamCaption}
\item[{}]{cs}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a0e43853c4c6b0f440005cc6b5124557e}
\begin{DoxyVerb}Convert a Chebyshev series to a polynomial.

Convert an array representing the coefficients of a Chebyshev series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the "standard" basis) ordered
from lowest to highest degree.

Parameters
----------
cs : array_like
    1-d array containing the Chebyshev series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-d array containing the coefficients of the equivalent polynomial
    (relative to the "standard" basis) ordered from lowest order term
    to highest.

See Also
--------
poly2cheb

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy import polynomial as P
>>> c = P.Chebyshev(range(4))
>>> c
Chebyshev([ 0.,  1.,  2.,  3.], [-1.,  1.])
>>> p = c.convert(kind=P.Polynomial)
>>> p
Polynomial([ -2.,  -8.,   4.,  12.], [-1.,  1.])
>>> P.cheb2poly(range(4))
array([ -2.,  -8.,   4.,  12.])\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00359}{359} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00359}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a0e43853c4c6b0f440005cc6b5124557e}{00359} 
00360 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a0e43853c4c6b0f440005cc6b5124557e}{cheb2poly}(cs) :
00361     \textcolor{stringliteral}{"""}
00362 \textcolor{stringliteral}{    Convert a Chebyshev series to a polynomial.}
00363 \textcolor{stringliteral}{}
00364 \textcolor{stringliteral}{    Convert an array representing the coefficients of a Chebyshev series,}
00365 \textcolor{stringliteral}{    ordered from lowest degree to highest, to an array of the coefficients}
00366 \textcolor{stringliteral}{    of the equivalent polynomial (relative to the "standard" basis) ordered}
00367 \textcolor{stringliteral}{    from lowest to highest degree.}
00368 \textcolor{stringliteral}{}
00369 \textcolor{stringliteral}{    Parameters}
00370 \textcolor{stringliteral}{    ----------}
00371 \textcolor{stringliteral}{    cs : array\_like}
00372 \textcolor{stringliteral}{        1-d array containing the Chebyshev series coefficients, ordered}
00373 \textcolor{stringliteral}{        from lowest order term to highest.}
00374 \textcolor{stringliteral}{}
00375 \textcolor{stringliteral}{    Returns}
00376 \textcolor{stringliteral}{    -------}
00377 \textcolor{stringliteral}{    pol : ndarray}
00378 \textcolor{stringliteral}{        1-d array containing the coefficients of the equivalent polynomial}
00379 \textcolor{stringliteral}{        (relative to the "standard" basis) ordered from lowest order term}
00380 \textcolor{stringliteral}{        to highest.}
00381 \textcolor{stringliteral}{}
00382 \textcolor{stringliteral}{    See Also}
00383 \textcolor{stringliteral}{    --------}
00384 \textcolor{stringliteral}{    poly2cheb}
00385 \textcolor{stringliteral}{}
00386 \textcolor{stringliteral}{    Notes}
00387 \textcolor{stringliteral}{    -----}
00388 \textcolor{stringliteral}{    The easy way to do conversions between polynomial basis sets}
00389 \textcolor{stringliteral}{    is to use the convert method of a class instance.}
00390 \textcolor{stringliteral}{}
00391 \textcolor{stringliteral}{    Examples}
00392 \textcolor{stringliteral}{    --------}
00393 \textcolor{stringliteral}{    >>> from numpy import polynomial as P}
00394 \textcolor{stringliteral}{    >>> c = P.Chebyshev(range(4))}
00395 \textcolor{stringliteral}{    >>> c}
00396 \textcolor{stringliteral}{    Chebyshev([ 0.,  1.,  2.,  3.], [-1.,  1.])}
00397 \textcolor{stringliteral}{    >>> p = c.convert(kind=P.Polynomial)}
00398 \textcolor{stringliteral}{    >>> p}
00399 \textcolor{stringliteral}{    Polynomial([ -2.,  -8.,   4.,  12.], [-1.,  1.])}
00400 \textcolor{stringliteral}{    >>> P.cheb2poly(range(4))}
00401 \textcolor{stringliteral}{    array([ -2.,  -8.,   4.,  12.])}
00402 \textcolor{stringliteral}{}
00403 \textcolor{stringliteral}{    """}
00404     \textcolor{keyword}{from} polynomial \textcolor{keyword}{import} polyadd, polysub, polymulx
00405 
00406     [cs] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([cs])
00407     n = len(cs)
00408     \textcolor{keywordflow}{if} n < 3:
00409         \textcolor{keywordflow}{return} cs
00410     \textcolor{keywordflow}{else}:
00411         c0 = cs[-2]
00412         c1 = cs[-1]
00413         \textcolor{comment}{# i is the current degree of c1}
00414         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(n - 1, 1, -1) :
00415             tmp = c0
00416             c0 = polysub(cs[i - 2], c1)
00417             c1 = polyadd(tmp, polymulx(c1)*2)
00418         \textcolor{keywordflow}{return} polyadd(c0, polymulx(c1))
00419 
00420 
00421 \textcolor{comment}{#}
00422 \textcolor{comment}{# These are constant arrays are of integer type so as to be compatible}
00423 \textcolor{comment}{# with the widest range of other types, such as Decimal.}
00424 \textcolor{comment}{#}
00425 
\textcolor{comment}{# Chebyshev default domain.}
\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_aafceea7ad9a5a18707fcf493bcf70457}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebadd@{chebadd}}
\index{chebadd@{chebadd}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebadd}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebadd (
\begin{DoxyParamCaption}
\item[{}]{c1, }
\item[{}]{c2}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_aafceea7ad9a5a18707fcf493bcf70457}
\begin{DoxyVerb}Add one Chebyshev series to another.

Returns the sum of two Chebyshev series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-d arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Chebyshev series of their sum.

See Also
--------
chebsub, chebmul, chebdiv, chebpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Chebyshev series
is a Chebyshev series (without having to "reproject" the result onto
the basis set) so addition, just like that of "standard" polynomials,
is simply "component-wise."

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> C.chebadd(c1,c2)
array([ 4.,  4.,  4.])\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00534}{534} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}, and \hyperlink{polyutils_8py_source_l00085}{pyneb.\-utils.\-polyutils.\-trimseq()}.



Referenced by \hyperlink{chebyshev_8py_source_l00309}{pyneb.\-utils.\-chebyshev.\-poly2cheb()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00534}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aafceea7ad9a5a18707fcf493bcf70457}{00534} 
00535 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aafceea7ad9a5a18707fcf493bcf70457}{chebadd}(c1, c2):
00536     \textcolor{stringliteral}{"""}
00537 \textcolor{stringliteral}{    Add one Chebyshev series to another.}
00538 \textcolor{stringliteral}{}
00539 \textcolor{stringliteral}{    Returns the sum of two Chebyshev series `c1` + `c2`.  The arguments}
00540 \textcolor{stringliteral}{    are sequences of coefficients ordered from lowest order term to}
00541 \textcolor{stringliteral}{    highest, i.e., [1,2,3] represents the series ``T\_0 + 2*T\_1 + 3*T\_2``.}
00542 \textcolor{stringliteral}{}
00543 \textcolor{stringliteral}{    Parameters}
00544 \textcolor{stringliteral}{    ----------}
00545 \textcolor{stringliteral}{    c1, c2 : array\_like}
00546 \textcolor{stringliteral}{        1-d arrays of Chebyshev series coefficients ordered from low to}
00547 \textcolor{stringliteral}{        high.}
00548 \textcolor{stringliteral}{}
00549 \textcolor{stringliteral}{    Returns}
00550 \textcolor{stringliteral}{    -------}
00551 \textcolor{stringliteral}{    out : ndarray}
00552 \textcolor{stringliteral}{        Array representing the Chebyshev series of their sum.}
00553 \textcolor{stringliteral}{}
00554 \textcolor{stringliteral}{    See Also}
00555 \textcolor{stringliteral}{    --------}
00556 \textcolor{stringliteral}{    chebsub, chebmul, chebdiv, chebpow}
00557 \textcolor{stringliteral}{}
00558 \textcolor{stringliteral}{    Notes}
00559 \textcolor{stringliteral}{    -----}
00560 \textcolor{stringliteral}{    Unlike multiplication, division, etc., the sum of two Chebyshev series}
00561 \textcolor{stringliteral}{    is a Chebyshev series (without having to "reproject" the result onto}
00562 \textcolor{stringliteral}{    the basis set) so addition, just like that of "standard" polynomials,}
00563 \textcolor{stringliteral}{    is simply "component-wise."}
00564 \textcolor{stringliteral}{}
00565 \textcolor{stringliteral}{    Examples}
00566 \textcolor{stringliteral}{    --------}
00567 \textcolor{stringliteral}{    >>> from numpy.polynomial import chebyshev as C}
00568 \textcolor{stringliteral}{    >>> c1 = (1,2,3)}
00569 \textcolor{stringliteral}{    >>> c2 = (3,2,1)}
00570 \textcolor{stringliteral}{    >>> C.chebadd(c1,c2)}
00571 \textcolor{stringliteral}{    array([ 4.,  4.,  4.])}
00572 \textcolor{stringliteral}{}
00573 \textcolor{stringliteral}{    """}
00574     \textcolor{comment}{# c1, c2 are trimmed copies}
00575     [c1, c2] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([c1, c2])
00576     \textcolor{keywordflow}{if} len(c1) > len(c2) :
00577         c1[:c2.size] += c2
00578         ret = c1
00579     \textcolor{keywordflow}{else} :
00580         c2[:c1.size] += c1
00581         ret = c2
00582     \textcolor{keywordflow}{return} \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{trimseq}(ret)
00583 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a1ed2b9248c247449584904025ec9d460}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebder@{chebder}}
\index{chebder@{chebder}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebder}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebder (
\begin{DoxyParamCaption}
\item[{}]{cs, }
\item[{}]{m = {\ttfamily 1}, }
\item[{}]{scl = {\ttfamily 1}}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a1ed2b9248c247449584904025ec9d460}
\begin{DoxyVerb}Differentiate a Chebyshev series.

Returns the series `cs` differentiated `m` times.  At each iteration the
result is multiplied by `scl` (the scaling factor is for use in a linear
change of variable).  The argument `cs` is the sequence of coefficients
from lowest order "term" to highest, e.g., [1,2,3] represents the series
``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
cs: array_like
    1-d array of Chebyshev series coefficients ordered from low to high.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)

Returns
-------
der : ndarray
    Chebyshev series of the derivative.

See Also
--------
chebint

Notes
-----
In general, the result of differentiating a C-series needs to be
"re-projected" onto the C-series basis set. Thus, typically, the
result of this function is "un-intuitive," albeit correct; see Examples
section below.

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> cs = (1,2,3,4)
>>> C.chebder(cs)
array([ 14.,  12.,  24.])
>>> C.chebder(cs,3)
array([ 96.])
>>> C.chebder(cs,scl=-1)
array([-14., -12., -24.])
>>> C.chebder(cs,2,-1)
array([ 12.,  96.])\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00841}{841} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{chebyshev_8py_source_l00100}{pyneb.\-utils.\-chebyshev.\-\_\-cseries\-\_\-to\-\_\-zseries()}, \hyperlink{chebyshev_8py_source_l00240}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-der()}, \hyperlink{chebyshev_8py_source_l00124}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-to\-\_\-cseries()}, and \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00841}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a1ed2b9248c247449584904025ec9d460}{00841} 
00842 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a1ed2b9248c247449584904025ec9d460}{chebder}(cs, m=1, scl=1) :
00843     \textcolor{stringliteral}{"""}
00844 \textcolor{stringliteral}{    Differentiate a Chebyshev series.}
00845 \textcolor{stringliteral}{}
00846 \textcolor{stringliteral}{    Returns the series `cs` differentiated `m` times.  At each iteration the}
00847 \textcolor{stringliteral}{    result is multiplied by `scl` (the scaling factor is for use in a linear}
00848 \textcolor{stringliteral}{    change of variable).  The argument `cs` is the sequence of coefficients}
00849 \textcolor{stringliteral}{    from lowest order "term" to highest, e.g., [1,2,3] represents the series}
00850 \textcolor{stringliteral}{    ``T\_0 + 2*T\_1 + 3*T\_2``.}
00851 \textcolor{stringliteral}{}
00852 \textcolor{stringliteral}{    Parameters}
00853 \textcolor{stringliteral}{    ----------}
00854 \textcolor{stringliteral}{    cs: array\_like}
00855 \textcolor{stringliteral}{        1-d array of Chebyshev series coefficients ordered from low to high.}
00856 \textcolor{stringliteral}{    m : int, optional}
00857 \textcolor{stringliteral}{        Number of derivatives taken, must be non-negative. (Default: 1)}
00858 \textcolor{stringliteral}{    scl : scalar, optional}
00859 \textcolor{stringliteral}{        Each differentiation is multiplied by `scl`.  The end result is}
00860 \textcolor{stringliteral}{        multiplication by ``scl**m``.  This is for use in a linear change of}
00861 \textcolor{stringliteral}{        variable. (Default: 1)}
00862 \textcolor{stringliteral}{}
00863 \textcolor{stringliteral}{    Returns}
00864 \textcolor{stringliteral}{    -------}
00865 \textcolor{stringliteral}{    der : ndarray}
00866 \textcolor{stringliteral}{        Chebyshev series of the derivative.}
00867 \textcolor{stringliteral}{}
00868 \textcolor{stringliteral}{    See Also}
00869 \textcolor{stringliteral}{    --------}
00870 \textcolor{stringliteral}{    chebint}
00871 \textcolor{stringliteral}{}
00872 \textcolor{stringliteral}{    Notes}
00873 \textcolor{stringliteral}{    -----}
00874 \textcolor{stringliteral}{    In general, the result of differentiating a C-series needs to be}
00875 \textcolor{stringliteral}{    "re-projected" onto the C-series basis set. Thus, typically, the}
00876 \textcolor{stringliteral}{    result of this function is "un-intuitive," albeit correct; see Examples}
00877 \textcolor{stringliteral}{    section below.}
00878 \textcolor{stringliteral}{}
00879 \textcolor{stringliteral}{    Examples}
00880 \textcolor{stringliteral}{    --------}
00881 \textcolor{stringliteral}{    >>> from numpy.polynomial import chebyshev as C}
00882 \textcolor{stringliteral}{    >>> cs = (1,2,3,4)}
00883 \textcolor{stringliteral}{    >>> C.chebder(cs)}
00884 \textcolor{stringliteral}{    array([ 14.,  12.,  24.])}
00885 \textcolor{stringliteral}{    >>> C.chebder(cs,3)}
00886 \textcolor{stringliteral}{    array([ 96.])}
00887 \textcolor{stringliteral}{    >>> C.chebder(cs,scl=-1)}
00888 \textcolor{stringliteral}{    array([-14., -12., -24.])}
00889 \textcolor{stringliteral}{    >>> C.chebder(cs,2,-1)}
00890 \textcolor{stringliteral}{    array([ 12.,  96.])}
00891 \textcolor{stringliteral}{}
00892 \textcolor{stringliteral}{    """}
00893     cnt = int(m)
00894 
00895     \textcolor{keywordflow}{if} cnt != m:
00896         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"The order of derivation must be integer"})
00897     \textcolor{keywordflow}{if} cnt < 0 :
00898         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"The order of derivation must be non-negative"})
00899 
00900     \textcolor{comment}{# cs is a trimmed copy}
00901     [cs] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([cs])
00902     \textcolor{keywordflow}{if} cnt == 0:
00903         \textcolor{keywordflow}{return} cs
00904     \textcolor{keywordflow}{elif} cnt >= len(cs):
00905         \textcolor{keywordflow}{return} cs[:1]*0
00906     \textcolor{keywordflow}{else} :
00907         zs = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{\_cseries\_to\_zseries}(cs)
00908         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(cnt):
00909             zs = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a82377769dc2ed2e38828ac99897ff554}{\_zseries\_der}(zs)*scl
00910         \textcolor{keywordflow}{return} \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}{\_zseries\_to\_cseries}(zs)
00911 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a5d4faaef412d6dfe502716e8e287d727}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebdiv@{chebdiv}}
\index{chebdiv@{chebdiv}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebdiv}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebdiv (
\begin{DoxyParamCaption}
\item[{}]{c1, }
\item[{}]{c2}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a5d4faaef412d6dfe502716e8e287d727}
\begin{DoxyVerb}Divide one Chebyshev series by another.

Returns the quotient-with-remainder of two Chebyshev series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order "term" to highest, e.g., [1,2,3] represents the series
``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-d arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Chebyshev series coefficients representing the quotient and
    remainder.

See Also
--------
chebadd, chebsub, chebmul, chebpow

Notes
-----
In general, the (polynomial) division of one C-series by another
results in quotient and remainder terms that are not in the Chebyshev
polynomial basis set.  Thus, to express these results as C-series, it
is typically necessary to "re-project" the results onto said basis
set, which typically produces "un-intuitive" (but correct) results;
see Examples section below.

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> C.chebdiv(c1,c2) # quotient "intuitive," remainder not
(array([ 3.]), array([-8., -4.]))
>>> c2 = (0,1,2,3)
>>> C.chebdiv(c2,c1) # neither "intuitive"
(array([ 0.,  2.]), array([-2., -4.]))\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00725}{725} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{chebyshev_8py_source_l00100}{pyneb.\-utils.\-chebyshev.\-\_\-cseries\-\_\-to\-\_\-zseries()}, \hyperlink{chebyshev_8py_source_l00174}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-div()}, \hyperlink{chebyshev_8py_source_l00124}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-to\-\_\-cseries()}, \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}, and \hyperlink{polyutils_8py_source_l00085}{pyneb.\-utils.\-polyutils.\-trimseq()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00725}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a5d4faaef412d6dfe502716e8e287d727}{00725} 
00726 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a5d4faaef412d6dfe502716e8e287d727}{chebdiv}(c1, c2):
00727     \textcolor{stringliteral}{"""}
00728 \textcolor{stringliteral}{    Divide one Chebyshev series by another.}
00729 \textcolor{stringliteral}{}
00730 \textcolor{stringliteral}{    Returns the quotient-with-remainder of two Chebyshev series}
00731 \textcolor{stringliteral}{    `c1` / `c2`.  The arguments are sequences of coefficients from lowest}
00732 \textcolor{stringliteral}{    order "term" to highest, e.g., [1,2,3] represents the series}
00733 \textcolor{stringliteral}{    ``T\_0 + 2*T\_1 + 3*T\_2``.}
00734 \textcolor{stringliteral}{}
00735 \textcolor{stringliteral}{    Parameters}
00736 \textcolor{stringliteral}{    ----------}
00737 \textcolor{stringliteral}{    c1, c2 : array\_like}
00738 \textcolor{stringliteral}{        1-d arrays of Chebyshev series coefficients ordered from low to}
00739 \textcolor{stringliteral}{        high.}
00740 \textcolor{stringliteral}{}
00741 \textcolor{stringliteral}{    Returns}
00742 \textcolor{stringliteral}{    -------}
00743 \textcolor{stringliteral}{    [quo, rem] : ndarrays}
00744 \textcolor{stringliteral}{        Of Chebyshev series coefficients representing the quotient and}
00745 \textcolor{stringliteral}{        remainder.}
00746 \textcolor{stringliteral}{}
00747 \textcolor{stringliteral}{    See Also}
00748 \textcolor{stringliteral}{    --------}
00749 \textcolor{stringliteral}{    chebadd, chebsub, chebmul, chebpow}
00750 \textcolor{stringliteral}{}
00751 \textcolor{stringliteral}{    Notes}
00752 \textcolor{stringliteral}{    -----}
00753 \textcolor{stringliteral}{    In general, the (polynomial) division of one C-series by another}
00754 \textcolor{stringliteral}{    results in quotient and remainder terms that are not in the Chebyshev}
00755 \textcolor{stringliteral}{    polynomial basis set.  Thus, to express these results as C-series, it}
00756 \textcolor{stringliteral}{    is typically necessary to "re-project" the results onto said basis}
00757 \textcolor{stringliteral}{    set, which typically produces "un-intuitive" (but correct) results;}
00758 \textcolor{stringliteral}{    see Examples section below.}
00759 \textcolor{stringliteral}{}
00760 \textcolor{stringliteral}{    Examples}
00761 \textcolor{stringliteral}{    --------}
00762 \textcolor{stringliteral}{    >>> from numpy.polynomial import chebyshev as C}
00763 \textcolor{stringliteral}{    >>> c1 = (1,2,3)}
00764 \textcolor{stringliteral}{    >>> c2 = (3,2,1)}
00765 \textcolor{stringliteral}{    >>> C.chebdiv(c1,c2) # quotient "intuitive," remainder not}
00766 \textcolor{stringliteral}{    (array([ 3.]), array([-8., -4.]))}
00767 \textcolor{stringliteral}{    >>> c2 = (0,1,2,3)}
00768 \textcolor{stringliteral}{    >>> C.chebdiv(c2,c1) # neither "intuitive"}
00769 \textcolor{stringliteral}{    (array([ 0.,  2.]), array([-2., -4.]))}
00770 \textcolor{stringliteral}{}
00771 \textcolor{stringliteral}{    """}
00772     \textcolor{comment}{# c1, c2 are trimmed copies}
00773     [c1, c2] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([c1, c2])
00774     \textcolor{keywordflow}{if} c2[-1] == 0 :
00775         \textcolor{keywordflow}{raise} ZeroDivisionError()
00776 
00777     lc1 = len(c1)
00778     lc2 = len(c2)
00779     \textcolor{keywordflow}{if} lc1 < lc2 :
00780         \textcolor{keywordflow}{return} c1[:1]*0, c1
00781     \textcolor{keywordflow}{elif} lc2 == 1 :
00782         \textcolor{keywordflow}{return} c1/c2[-1], c1[:1]*0
00783     \textcolor{keywordflow}{else} :
00784         z1 = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{\_cseries\_to\_zseries}(c1)
00785         z2 = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{\_cseries\_to\_zseries}(c2)
00786         quo, rem = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a9ec3445ca77071adc655bacf9299c451}{\_zseries\_div}(z1, z2)
00787         quo = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{trimseq}(\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}{\_zseries\_to\_cseries}(quo))
00788         rem = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{trimseq}(\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}{\_zseries\_to\_cseries}(rem))
00789         \textcolor{keywordflow}{return} quo, rem

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a6bb5eb95525fd0572aea52fcd2a12c6c}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebfit@{chebfit}}
\index{chebfit@{chebfit}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebfit}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebfit (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{y, }
\item[{}]{deg, }
\item[{}]{rcond = {\ttfamily None}, }
\item[{}]{full = {\ttfamily False}, }
\item[{}]{w = {\ttfamily None}}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a6bb5eb95525fd0572aea52fcd2a12c6c}
\begin{DoxyVerb}Least squares fit of Chebyshev series to data.

Fit a Chebyshev series ``p(x) = p[0] * T_{0}(x) + ... + p[deg] *
T_{deg}(x)`` of degree `deg` to points `(x, y)`. Returns a vector of
coefficients `p` that minimises the squared error.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.
    .. versionadded:: 1.5.0

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Chebyshev coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : present when `full` = True
    Residuals of the least-squares fit, the effective rank of the
    scaled Vandermonde matrix and its singular values, and the
    specified value of `rcond`. For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    >>> import warnings
    >>> warnings.simplefilter('ignore', RankWarning)

See Also
--------
chebval : Evaluates a Chebyshev series.
chebvander : Vandermonde matrix of Chebyshev series.
polyfit : least squares fit using polynomials.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution are the coefficients ``c[i]`` of the Chebyshev series
``T(x)`` that minimizes the squared error

``E = \\sum_j |y_j - T(x_j)|^2``.

This problem is solved by setting up as the overdetermined matrix
equation

``V(x)*c = y``,

where ``V`` is the Vandermonde matrix of `x`, the elements of ``c`` are
the coefficients to be solved for, and the elements of `y` are the
observed values.  This equation is then solved using the singular value
decomposition of ``V``.

If some of the singular values of ``V`` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coeficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using Chebyshev series are usually better conditioned than fits
using power series, but much can depend on the distribution of the
sample points and the smoothness of the data. If the quality of the fit
is inadequate splines may be a good alternative.

References
----------
.. [1] Wikipedia, "Curve fitting",
       http://en.wikipedia.org/wiki/Curve_fitting

Examples
--------\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l01121}{1121} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{chebyshev_8py_source_l01078}{pyneb.\-utils.\-chebyshev.\-chebvander()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l01121}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a6bb5eb95525fd0572aea52fcd2a12c6c}{01121} 
01122 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a6bb5eb95525fd0572aea52fcd2a12c6c}{chebfit}(x, y, deg, rcond=None, full=False, w=None):
01123     \textcolor{stringliteral}{"""}
01124 \textcolor{stringliteral}{    Least squares fit of Chebyshev series to data.}
01125 \textcolor{stringliteral}{}
01126 \textcolor{stringliteral}{    Fit a Chebyshev series ``p(x) = p[0] * T\_\{0\}(x) + ... + p[deg] *}
01127 \textcolor{stringliteral}{    T\_\{deg\}(x)`` of degree `deg` to points `(x, y)`. Returns a vector of}
01128 \textcolor{stringliteral}{    coefficients `p` that minimises the squared error.}
01129 \textcolor{stringliteral}{}
01130 \textcolor{stringliteral}{    Parameters}
01131 \textcolor{stringliteral}{    ----------}
01132 \textcolor{stringliteral}{    x : array\_like, shape (M,)}
01133 \textcolor{stringliteral}{        x-coordinates of the M sample points ``(x[i], y[i])``.}
01134 \textcolor{stringliteral}{    y : array\_like, shape (M,) or (M, K)}
01135 \textcolor{stringliteral}{        y-coordinates of the sample points. Several data sets of sample}
01136 \textcolor{stringliteral}{        points sharing the same x-coordinates can be fitted at once by}
01137 \textcolor{stringliteral}{        passing in a 2D-array that contains one dataset per column.}
01138 \textcolor{stringliteral}{    deg : int}
01139 \textcolor{stringliteral}{        Degree of the fitting polynomial}
01140 \textcolor{stringliteral}{    rcond : float, optional}
01141 \textcolor{stringliteral}{        Relative condition number of the fit. Singular values smaller than}
01142 \textcolor{stringliteral}{        this relative to the largest singular value will be ignored. The}
01143 \textcolor{stringliteral}{        default value is len(x)*eps, where eps is the relative precision of}
01144 \textcolor{stringliteral}{        the float type, about 2e-16 in most cases.}
01145 \textcolor{stringliteral}{    full : bool, optional}
01146 \textcolor{stringliteral}{        Switch determining nature of return value. When it is False (the}
01147 \textcolor{stringliteral}{        default) just the coefficients are returned, when True diagnostic}
01148 \textcolor{stringliteral}{        information from the singular value decomposition is also returned.}
01149 \textcolor{stringliteral}{    w : array\_like, shape (`M`,), optional}
01150 \textcolor{stringliteral}{        Weights. If not None, the contribution of each point}
01151 \textcolor{stringliteral}{        ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the}
01152 \textcolor{stringliteral}{        weights are chosen so that the errors of the products ``w[i]*y[i]``}
01153 \textcolor{stringliteral}{        all have the same variance.  The default value is None.}
01154 \textcolor{stringliteral}{        .. versionadded:: 1.5.0}
01155 \textcolor{stringliteral}{}
01156 \textcolor{stringliteral}{    Returns}
01157 \textcolor{stringliteral}{    -------}
01158 \textcolor{stringliteral}{    coef : ndarray, shape (M,) or (M, K)}
01159 \textcolor{stringliteral}{        Chebyshev coefficients ordered from low to high. If `y` was 2-D,}
01160 \textcolor{stringliteral}{        the coefficients for the data in column k  of `y` are in column}
01161 \textcolor{stringliteral}{        `k`.}
01162 \textcolor{stringliteral}{}
01163 \textcolor{stringliteral}{    [residuals, rank, singular\_values, rcond] : present when `full` = True}
01164 \textcolor{stringliteral}{        Residuals of the least-squares fit, the effective rank of the}
01165 \textcolor{stringliteral}{        scaled Vandermonde matrix and its singular values, and the}
01166 \textcolor{stringliteral}{        specified value of `rcond`. For more details, see `linalg.lstsq`.}
01167 \textcolor{stringliteral}{}
01168 \textcolor{stringliteral}{    Warns}
01169 \textcolor{stringliteral}{    -----}
01170 \textcolor{stringliteral}{    RankWarning}
01171 \textcolor{stringliteral}{        The rank of the coefficient matrix in the least-squares fit is}
01172 \textcolor{stringliteral}{        deficient. The warning is only raised if `full` = False.  The}
01173 \textcolor{stringliteral}{        warnings can be turned off by}
01174 \textcolor{stringliteral}{}
01175 \textcolor{stringliteral}{        >>> import warnings}
01176 \textcolor{stringliteral}{        >>> warnings.simplefilter('ignore', RankWarning)}
01177 \textcolor{stringliteral}{}
01178 \textcolor{stringliteral}{    See Also}
01179 \textcolor{stringliteral}{    --------}
01180 \textcolor{stringliteral}{    chebval : Evaluates a Chebyshev series.}
01181 \textcolor{stringliteral}{    chebvander : Vandermonde matrix of Chebyshev series.}
01182 \textcolor{stringliteral}{    polyfit : least squares fit using polynomials.}
01183 \textcolor{stringliteral}{    linalg.lstsq : Computes a least-squares fit from the matrix.}
01184 \textcolor{stringliteral}{    scipy.interpolate.UnivariateSpline : Computes spline fits.}
01185 \textcolor{stringliteral}{}
01186 \textcolor{stringliteral}{    Notes}
01187 \textcolor{stringliteral}{    -----}
01188 \textcolor{stringliteral}{    The solution are the coefficients ``c[i]`` of the Chebyshev series}
01189 \textcolor{stringliteral}{    ``T(x)`` that minimizes the squared error}
01190 \textcolor{stringliteral}{}
01191 \textcolor{stringliteral}{    ``E = \(\backslash\)\(\backslash\)sum\_j |y\_j - T(x\_j)|^2``.}
01192 \textcolor{stringliteral}{}
01193 \textcolor{stringliteral}{    This problem is solved by setting up as the overdetermined matrix}
01194 \textcolor{stringliteral}{    equation}
01195 \textcolor{stringliteral}{}
01196 \textcolor{stringliteral}{    ``V(x)*c = y``,}
01197 \textcolor{stringliteral}{}
01198 \textcolor{stringliteral}{    where ``V`` is the Vandermonde matrix of `x`, the elements of ``c`` are}
01199 \textcolor{stringliteral}{    the coefficients to be solved for, and the elements of `y` are the}
01200 \textcolor{stringliteral}{    observed values.  This equation is then solved using the singular value}
01201 \textcolor{stringliteral}{    decomposition of ``V``.}
01202 \textcolor{stringliteral}{}
01203 \textcolor{stringliteral}{    If some of the singular values of ``V`` are so small that they are}
01204 \textcolor{stringliteral}{    neglected, then a `RankWarning` will be issued. This means that the}
01205 \textcolor{stringliteral}{    coeficient values may be poorly determined. Using a lower order fit}
01206 \textcolor{stringliteral}{    will usually get rid of the warning.  The `rcond` parameter can also be}
01207 \textcolor{stringliteral}{    set to a value smaller than its default, but the resulting fit may be}
01208 \textcolor{stringliteral}{    spurious and have large contributions from roundoff error.}
01209 \textcolor{stringliteral}{}
01210 \textcolor{stringliteral}{    Fits using Chebyshev series are usually better conditioned than fits}
01211 \textcolor{stringliteral}{    using power series, but much can depend on the distribution of the}
01212 \textcolor{stringliteral}{    sample points and the smoothness of the data. If the quality of the fit}
01213 \textcolor{stringliteral}{    is inadequate splines may be a good alternative.}
01214 \textcolor{stringliteral}{}
01215 \textcolor{stringliteral}{    References}
01216 \textcolor{stringliteral}{    ----------}
01217 \textcolor{stringliteral}{    .. [1] Wikipedia, "Curve fitting",}
01218 \textcolor{stringliteral}{           http://en.wikipedia.org/wiki/Curve\_fitting}
01219 \textcolor{stringliteral}{}
01220 \textcolor{stringliteral}{    Examples}
01221 \textcolor{stringliteral}{    --------}
01222 \textcolor{stringliteral}{}
01223 \textcolor{stringliteral}{    """}
01224     order = int(deg) + 1
01225     x = np.asarray(x) + 0.0
01226     y = np.asarray(y) + 0.0
01227 
01228     \textcolor{comment}{# check arguments.}
01229     \textcolor{keywordflow}{if} deg < 0 :
01230         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"expected deg >= 0"})
01231     \textcolor{keywordflow}{if} x.ndim != 1:
01232         \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{"expected 1D vector for x"})
01233     \textcolor{keywordflow}{if} x.size == 0:
01234         \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{"expected non-empty vector for x"})
01235     \textcolor{keywordflow}{if} y.ndim < 1 \textcolor{keywordflow}{or} y.ndim > 2 :
01236         \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{"expected 1D or 2D array for y"})
01237     \textcolor{keywordflow}{if} len(x) != len(y):
01238         \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{"expected x and y to have same length"})
01239 
01240     \textcolor{comment}{# set up the least squares matrices}
01241     lhs = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a4a53ad781fcf149c5ab6ae5d021b0950}{chebvander}(x, deg)
01242     rhs = y
01243     \textcolor{keywordflow}{if} w \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
01244         w = np.asarray(w) + 0.0
01245         \textcolor{keywordflow}{if} w.ndim != 1:
01246             \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{"expected 1D vector for w"})
01247         \textcolor{keywordflow}{if} len(x) != len(w):
01248             \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{"expected x and w to have same length"})
01249         \textcolor{comment}{# apply weights}
01250         \textcolor{keywordflow}{if} rhs.ndim == 2:
01251             lhs *= w[:, np.newaxis]
01252             rhs *= w[:, np.newaxis]
01253         \textcolor{keywordflow}{else}:
01254             lhs *= w[:, np.newaxis]
01255             rhs *= w
01256 
01257     \textcolor{comment}{# set rcond}
01258     \textcolor{keywordflow}{if} rcond \textcolor{keywordflow}{is} \textcolor{keywordtype}{None} :
01259         rcond = len(x)*np.finfo(x.dtype).eps
01260 
01261     \textcolor{comment}{# scale the design matrix and solve the least squares equation}
01262     scl = np.sqrt((lhs*lhs).sum(0))
01263     c, resids, rank, s = la.lstsq(lhs/scl, rhs, rcond)
01264     c = (c.T/scl).T
01265 
01266     \textcolor{comment}{# warn on rank reduction}
01267     \textcolor{keywordflow}{if} rank != order \textcolor{keywordflow}{and} \textcolor{keywordflow}{not} full:
01268         msg = \textcolor{stringliteral}{"The fit may be poorly conditioned"}
01269         warnings.warn(msg, RankWarning)
01270 
01271     \textcolor{keywordflow}{if} full :
01272         \textcolor{keywordflow}{return} c, [resids, rank, s, rcond]
01273     \textcolor{keywordflow}{else} :
01274         \textcolor{keywordflow}{return} c
01275 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_ad3dc62fdecc545593e36509daa1c2632}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebfromroots@{chebfromroots}}
\index{chebfromroots@{chebfromroots}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebfromroots}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebfromroots (
\begin{DoxyParamCaption}
\item[{}]{roots}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_ad3dc62fdecc545593e36509daa1c2632}
\begin{DoxyVerb}Generate a Chebyshev series with the given roots.

Return the array of coefficients for the C-series whose roots (a.k.a.
"zeros") are given by *roots*.  The returned array of coefficients is
ordered from lowest order "term" to highest, and zeros of multiplicity
greater than one must be included in *roots* a number of times equal
to their multiplicity (e.g., if `2` is a root of multiplicity three,
then [2,2,2] must be in *roots*).

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-d array of the C-series' coefficients, ordered from low to
    high.  If all roots are real, ``out.dtype`` is a float type;
    otherwise, ``out.dtype`` is a complex type, even if all the
    coefficients in the result are real (see Examples below).

See Also
--------
polyfromroots

Notes
-----
What is returned are the :math:`c_i` such that:

.. math::

    \\sum_{i=0}^{n} c_i*T_i(x) = \\prod_{i=0}^{n} (x - roots[i])

where ``n == len(roots)`` and :math:`T_i(x)` is the `i`-th Chebyshev
(basis) polynomial over the domain `[-1,1]`.  Note that, unlike
`polyfromroots`, due to the nature of the C-series basis set, the
above identity *does not* imply :math:`c_n = 1` identically (see
Examples).

Examples
--------
>>> import numpy.polynomial.chebyshev as C
>>> C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis
array([ 0.  , -0.25,  0.  ,  0.25])
>>> j = complex(0,1)
>>> C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis
array([ 1.5+0.j,  0.0+0.j,  0.5+0.j])\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00472}{472} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}, \hyperlink{chebyshev_8py_source_l00637}{pyneb.\-utils.\-chebyshev.\-chebmulx()}, and \hyperlink{chebyshev_8py_source_l00584}{pyneb.\-utils.\-chebyshev.\-chebsub()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00472}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ad3dc62fdecc545593e36509daa1c2632}{00472} 
00473 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ad3dc62fdecc545593e36509daa1c2632}{chebfromroots}(roots) :
00474     \textcolor{stringliteral}{"""}
00475 \textcolor{stringliteral}{    Generate a Chebyshev series with the given roots.}
00476 \textcolor{stringliteral}{}
00477 \textcolor{stringliteral}{    Return the array of coefficients for the C-series whose roots (a.k.a.}
00478 \textcolor{stringliteral}{    "zeros") are given by *roots*.  The returned array of coefficients is}
00479 \textcolor{stringliteral}{    ordered from lowest order "term" to highest, and zeros of multiplicity}
00480 \textcolor{stringliteral}{    greater than one must be included in *roots* a number of times equal}
00481 \textcolor{stringliteral}{    to their multiplicity (e.g., if `2` is a root of multiplicity three,}
00482 \textcolor{stringliteral}{    then [2,2,2] must be in *roots*).}
00483 \textcolor{stringliteral}{}
00484 \textcolor{stringliteral}{    Parameters}
00485 \textcolor{stringliteral}{    ----------}
00486 \textcolor{stringliteral}{    roots : array\_like}
00487 \textcolor{stringliteral}{        Sequence containing the roots.}
00488 \textcolor{stringliteral}{}
00489 \textcolor{stringliteral}{    Returns}
00490 \textcolor{stringliteral}{    -------}
00491 \textcolor{stringliteral}{    out : ndarray}
00492 \textcolor{stringliteral}{        1-d array of the C-series' coefficients, ordered from low to}
00493 \textcolor{stringliteral}{        high.  If all roots are real, ``out.dtype`` is a float type;}
00494 \textcolor{stringliteral}{        otherwise, ``out.dtype`` is a complex type, even if all the}
00495 \textcolor{stringliteral}{        coefficients in the result are real (see Examples below).}
00496 \textcolor{stringliteral}{}
00497 \textcolor{stringliteral}{    See Also}
00498 \textcolor{stringliteral}{    --------}
00499 \textcolor{stringliteral}{    polyfromroots}
00500 \textcolor{stringliteral}{}
00501 \textcolor{stringliteral}{    Notes}
00502 \textcolor{stringliteral}{    -----}
00503 \textcolor{stringliteral}{    What is returned are the :math:`c\_i` such that:}
00504 \textcolor{stringliteral}{}
00505 \textcolor{stringliteral}{    .. math::}
00506 \textcolor{stringliteral}{}
00507 \textcolor{stringliteral}{        \(\backslash\)\(\backslash\)sum\_\{i=0\}^\{n\} c\_i*T\_i(x) = \(\backslash\)\(\backslash\)prod\_\{i=0\}^\{n\} (x - roots[i])}
00508 \textcolor{stringliteral}{}
00509 \textcolor{stringliteral}{    where ``n == len(roots)`` and :math:`T\_i(x)` is the `i`-th Chebyshev}
00510 \textcolor{stringliteral}{    (basis) polynomial over the domain `[-1,1]`.  Note that, unlike}
00511 \textcolor{stringliteral}{    `polyfromroots`, due to the nature of the C-series basis set, the}
00512 \textcolor{stringliteral}{    above identity *does not* imply :math:`c\_n = 1` identically (see}
00513 \textcolor{stringliteral}{    Examples).}
00514 \textcolor{stringliteral}{}
00515 \textcolor{stringliteral}{    Examples}
00516 \textcolor{stringliteral}{    --------}
00517 \textcolor{stringliteral}{    >>> import numpy.polynomial.chebyshev as C}
00518 \textcolor{stringliteral}{    >>> C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis}
00519 \textcolor{stringliteral}{    array([ 0.  , -0.25,  0.  ,  0.25])}
00520 \textcolor{stringliteral}{    >>> j = complex(0,1)}
00521 \textcolor{stringliteral}{    >>> C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis}
00522 \textcolor{stringliteral}{    array([ 1.5+0.j,  0.0+0.j,  0.5+0.j])}
00523 \textcolor{stringliteral}{}
00524 \textcolor{stringliteral}{    """}
00525     \textcolor{keywordflow}{if} len(roots) == 0 :
00526         \textcolor{keywordflow}{return} np.ones(1)
00527     \textcolor{keywordflow}{else} :
00528         [roots] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([roots], trim=\textcolor{keyword}{False})
00529         prd = np.array([1], dtype=roots.dtype)
00530         \textcolor{keywordflow}{for} r \textcolor{keywordflow}{in} roots:
00531             prd = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a2ca3ca3bac02e30625edb4c48ada7ddf}{chebsub}(\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a91d78fa31041dfe9ccf7bbc0891809b3}{chebmulx}(prd), r*prd)
00532         \textcolor{keywordflow}{return} prd
00533 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a233e686a07b9935c74ce1e053f0c5f5f}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebint@{chebint}}
\index{chebint@{chebint}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebint}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebint (
\begin{DoxyParamCaption}
\item[{}]{cs, }
\item[{}]{m = {\ttfamily 1}, }
\item[{}]{k = {\ttfamily \mbox{[}\mbox{]}}, }
\item[{}]{lbnd = {\ttfamily 0}, }
\item[{}]{scl = {\ttfamily 1}}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a233e686a07b9935c74ce1e053f0c5f5f}
\begin{DoxyVerb}Integrate a Chebyshev series.

Returns, as a C-series, the input C-series `cs`, integrated `m` times
from `lbnd` to `x`.  At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ("Buyer
beware": note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `cs` is a sequence of
coefficients, from lowest order C-series "term" to highest, e.g.,
[1,2,3] represents the series :math:`T_0(x) + 2T_1(x) + 3T_2(x)`.

Parameters
----------
cs : array_like
    1-d array of C-series coefficients, ordered from low to high.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at zero
    is the first value in the list, the value of the second integral
    at zero is the second value, etc.  If ``k == []`` (the default),
    all constants are set to zero.  If ``m == 1``, a single scalar can
    be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)

Returns
-------
S : ndarray
    C-series coefficients of the integral.

Raises
------
ValueError
    If ``m < 1``, ``len(k) > m``, ``np.isscalar(lbnd) == False``, or
    ``np.isscalar(scl) == False``.

See Also
--------
chebder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
:math:`dx = du/a`, so one will need to set `scl` equal to :math:`1/a`
- perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be "re-projected" onto the C-series basis set.  Thus, typically,
the result of this function is "un-intuitive," albeit correct; see
Examples section below.

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> cs = (1,2,3)
>>> C.chebint(cs)
array([ 0.5, -0.5,  0.5,  0.5])
>>> C.chebint(cs,3)
array([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667,
        0.00625   ])
>>> C.chebint(cs, k=3)
array([ 3.5, -0.5,  0.5,  0.5])
>>> C.chebint(cs,lbnd=-2)
array([ 8.5, -0.5,  0.5,  0.5])
>>> C.chebint(cs,scl=-2)
array([-1.,  1., -1., -1.])\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00912}{912} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{chebyshev_8py_source_l00100}{pyneb.\-utils.\-chebyshev.\-\_\-cseries\-\_\-to\-\_\-zseries()}, \hyperlink{chebyshev_8py_source_l00271}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-int()}, \hyperlink{chebyshev_8py_source_l00124}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-to\-\_\-cseries()}, \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}, and \hyperlink{chebyshev_8py_source_l01018}{pyneb.\-utils.\-chebyshev.\-chebval()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00912}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a233e686a07b9935c74ce1e053f0c5f5f}{00912} 
00913 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a233e686a07b9935c74ce1e053f0c5f5f}{chebint}(cs, m=1, k=[], lbnd=0, scl=1):
00914     \textcolor{stringliteral}{"""}
00915 \textcolor{stringliteral}{    Integrate a Chebyshev series.}
00916 \textcolor{stringliteral}{}
00917 \textcolor{stringliteral}{    Returns, as a C-series, the input C-series `cs`, integrated `m` times}
00918 \textcolor{stringliteral}{    from `lbnd` to `x`.  At each iteration the resulting series is}
00919 \textcolor{stringliteral}{    **multiplied** by `scl` and an integration constant, `k`, is added.}
00920 \textcolor{stringliteral}{    The scaling factor is for use in a linear change of variable.  ("Buyer}
00921 \textcolor{stringliteral}{    beware": note that, depending on what one is doing, one may want `scl`}
00922 \textcolor{stringliteral}{    to be the reciprocal of what one might expect; for more information,}
00923 \textcolor{stringliteral}{    see the Notes section below.)  The argument `cs` is a sequence of}
00924 \textcolor{stringliteral}{    coefficients, from lowest order C-series "term" to highest, e.g.,}
00925 \textcolor{stringliteral}{    [1,2,3] represents the series :math:`T\_0(x) + 2T\_1(x) + 3T\_2(x)`.}
00926 \textcolor{stringliteral}{}
00927 \textcolor{stringliteral}{    Parameters}
00928 \textcolor{stringliteral}{    ----------}
00929 \textcolor{stringliteral}{    cs : array\_like}
00930 \textcolor{stringliteral}{        1-d array of C-series coefficients, ordered from low to high.}
00931 \textcolor{stringliteral}{    m : int, optional}
00932 \textcolor{stringliteral}{        Order of integration, must be positive. (Default: 1)}
00933 \textcolor{stringliteral}{    k : \{[], list, scalar\}, optional}
00934 \textcolor{stringliteral}{        Integration constant(s).  The value of the first integral at zero}
00935 \textcolor{stringliteral}{        is the first value in the list, the value of the second integral}
00936 \textcolor{stringliteral}{        at zero is the second value, etc.  If ``k == []`` (the default),}
00937 \textcolor{stringliteral}{        all constants are set to zero.  If ``m == 1``, a single scalar can}
00938 \textcolor{stringliteral}{        be given instead of a list.}
00939 \textcolor{stringliteral}{    lbnd : scalar, optional}
00940 \textcolor{stringliteral}{        The lower bound of the integral. (Default: 0)}
00941 \textcolor{stringliteral}{    scl : scalar, optional}
00942 \textcolor{stringliteral}{        Following each integration the result is *multiplied* by `scl`}
00943 \textcolor{stringliteral}{        before the integration constant is added. (Default: 1)}
00944 \textcolor{stringliteral}{}
00945 \textcolor{stringliteral}{    Returns}
00946 \textcolor{stringliteral}{    -------}
00947 \textcolor{stringliteral}{    S : ndarray}
00948 \textcolor{stringliteral}{        C-series coefficients of the integral.}
00949 \textcolor{stringliteral}{}
00950 \textcolor{stringliteral}{    Raises}
00951 \textcolor{stringliteral}{    ------}
00952 \textcolor{stringliteral}{    ValueError}
00953 \textcolor{stringliteral}{        If ``m < 1``, ``len(k) > m``, ``np.isscalar(lbnd) == False``, or}
00954 \textcolor{stringliteral}{        ``np.isscalar(scl) == False``.}
00955 \textcolor{stringliteral}{}
00956 \textcolor{stringliteral}{    See Also}
00957 \textcolor{stringliteral}{    --------}
00958 \textcolor{stringliteral}{    chebder}
00959 \textcolor{stringliteral}{}
00960 \textcolor{stringliteral}{    Notes}
00961 \textcolor{stringliteral}{    -----}
00962 \textcolor{stringliteral}{    Note that the result of each integration is *multiplied* by `scl`.}
00963 \textcolor{stringliteral}{    Why is this important to note?  Say one is making a linear change of}
00964 \textcolor{stringliteral}{    variable :math:`u = ax + b` in an integral relative to `x`.  Then}
00965 \textcolor{stringliteral}{    :math:`dx = du/a`, so one will need to set `scl` equal to :math:`1/a`}
00966 \textcolor{stringliteral}{    - perhaps not what one would have first thought.}
00967 \textcolor{stringliteral}{}
00968 \textcolor{stringliteral}{    Also note that, in general, the result of integrating a C-series needs}
00969 \textcolor{stringliteral}{    to be "re-projected" onto the C-series basis set.  Thus, typically,}
00970 \textcolor{stringliteral}{    the result of this function is "un-intuitive," albeit correct; see}
00971 \textcolor{stringliteral}{    Examples section below.}
00972 \textcolor{stringliteral}{}
00973 \textcolor{stringliteral}{    Examples}
00974 \textcolor{stringliteral}{    --------}
00975 \textcolor{stringliteral}{    >>> from numpy.polynomial import chebyshev as C}
00976 \textcolor{stringliteral}{    >>> cs = (1,2,3)}
00977 \textcolor{stringliteral}{    >>> C.chebint(cs)}
00978 \textcolor{stringliteral}{    array([ 0.5, -0.5,  0.5,  0.5])}
00979 \textcolor{stringliteral}{    >>> C.chebint(cs,3)}
00980 \textcolor{stringliteral}{    array([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667,}
00981 \textcolor{stringliteral}{            0.00625   ])}
00982 \textcolor{stringliteral}{    >>> C.chebint(cs, k=3)}
00983 \textcolor{stringliteral}{    array([ 3.5, -0.5,  0.5,  0.5])}
00984 \textcolor{stringliteral}{    >>> C.chebint(cs,lbnd=-2)}
00985 \textcolor{stringliteral}{    array([ 8.5, -0.5,  0.5,  0.5])}
00986 \textcolor{stringliteral}{    >>> C.chebint(cs,scl=-2)}
00987 \textcolor{stringliteral}{    array([-1.,  1., -1., -1.])}
00988 \textcolor{stringliteral}{}
00989 \textcolor{stringliteral}{    """}
00990     cnt = int(m)
00991     \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} np.iterable(k):
00992         k = [k]
00993 
00994     \textcolor{keywordflow}{if} cnt != m:
00995         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"The order of integration must be integer"})
00996     \textcolor{keywordflow}{if} cnt < 0 :
00997         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"The order of integration must be non-negative"})
00998     \textcolor{keywordflow}{if} len(k) > cnt :
00999         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"Too many integration constants"})
01000 
01001     \textcolor{comment}{# cs is a trimmed copy}
01002     [cs] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([cs])
01003     \textcolor{keywordflow}{if} cnt == 0:
01004         \textcolor{keywordflow}{return} cs
01005 
01006     k = list(k) + [0]*(cnt - len(k))
01007     \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(cnt) :
01008         n = len(cs)
01009         cs *= scl
01010         \textcolor{keywordflow}{if} n == 1 \textcolor{keywordflow}{and} cs[0] == 0:
01011             cs[0] += k[i]
01012         \textcolor{keywordflow}{else}:
01013             zs = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{\_cseries\_to\_zseries}(cs)
01014             zs = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ac55f3063cff69831a2882a7a30b617d7}{\_zseries\_int}(zs)
01015             cs = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}{\_zseries\_to\_cseries}(zs)
01016             cs[0] += k[i] - \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a44ae40c5b4cbdc3a230c014c834f5ce6}{chebval}(lbnd, cs)
01017     \textcolor{keywordflow}{return} cs

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_ab88a5c9a7faa4458231ddb2edc1aa860}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebline@{chebline}}
\index{chebline@{chebline}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebline}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebline (
\begin{DoxyParamCaption}
\item[{}]{off, }
\item[{}]{scl}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_ab88a5c9a7faa4458231ddb2edc1aa860}
\begin{DoxyVerb}Chebyshev series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Chebyshev series for
    ``off + scl*x``.

See Also
--------
polyline

Examples
--------
>>> import numpy.polynomial.chebyshev as C
>>> C.chebline(3,2)
array([3, 2])
>>> C.chebval(-3, C.chebline(3,2)) # should be -3
-3.0\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00437}{437} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00437}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ab88a5c9a7faa4458231ddb2edc1aa860}{00437} 
00438 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ab88a5c9a7faa4458231ddb2edc1aa860}{chebline}(off, scl) :
00439     \textcolor{stringliteral}{"""}
00440 \textcolor{stringliteral}{    Chebyshev series whose graph is a straight line.}
00441 \textcolor{stringliteral}{}
00442 \textcolor{stringliteral}{}
00443 \textcolor{stringliteral}{}
00444 \textcolor{stringliteral}{    Parameters}
00445 \textcolor{stringliteral}{    ----------}
00446 \textcolor{stringliteral}{    off, scl : scalars}
00447 \textcolor{stringliteral}{        The specified line is given by ``off + scl*x``.}
00448 \textcolor{stringliteral}{}
00449 \textcolor{stringliteral}{    Returns}
00450 \textcolor{stringliteral}{    -------}
00451 \textcolor{stringliteral}{    y : ndarray}
00452 \textcolor{stringliteral}{        This module's representation of the Chebyshev series for}
00453 \textcolor{stringliteral}{        ``off + scl*x``.}
00454 \textcolor{stringliteral}{}
00455 \textcolor{stringliteral}{    See Also}
00456 \textcolor{stringliteral}{    --------}
00457 \textcolor{stringliteral}{    polyline}
00458 \textcolor{stringliteral}{}
00459 \textcolor{stringliteral}{    Examples}
00460 \textcolor{stringliteral}{    --------}
00461 \textcolor{stringliteral}{    >>> import numpy.polynomial.chebyshev as C}
00462 \textcolor{stringliteral}{    >>> C.chebline(3,2)}
00463 \textcolor{stringliteral}{    array([3, 2])}
00464 \textcolor{stringliteral}{    >>> C.chebval(-3, C.chebline(3,2)) # should be -3}
00465 \textcolor{stringliteral}{    -3.0}
00466 \textcolor{stringliteral}{}
00467 \textcolor{stringliteral}{    """}
00468     \textcolor{keywordflow}{if} scl != 0 :
00469         \textcolor{keywordflow}{return} np.array([off,scl])
00470     \textcolor{keywordflow}{else} :
00471         \textcolor{keywordflow}{return} np.array([off])

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a20beb101adf242958f21dff04591e1ca}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebmul@{chebmul}}
\index{chebmul@{chebmul}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebmul}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebmul (
\begin{DoxyParamCaption}
\item[{}]{c1, }
\item[{}]{c2}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a20beb101adf242958f21dff04591e1ca}
\begin{DoxyVerb}Multiply one Chebyshev series by another.

Returns the product of two Chebyshev series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order "term" to highest,
e.g., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-d arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Chebyshev series coefficients representing their product.

See Also
--------
chebadd, chebsub, chebdiv, chebpow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Chebyshev polynomial basis set.  Thus, to express
the product as a C-series, it is typically necessary to "re-project"
the product onto said basis set, which typically produces
"un-intuitive" (but correct) results; see Examples section below.

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> C.chebmul(c1,c2) # multiplication requires "reprojection"
array([  6.5,  12. ,  12. ,   4. ,   1.5])\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00676}{676} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{chebyshev_8py_source_l00100}{pyneb.\-utils.\-chebyshev.\-\_\-cseries\-\_\-to\-\_\-zseries()}, \hyperlink{chebyshev_8py_source_l00148}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-mul()}, \hyperlink{chebyshev_8py_source_l00124}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-to\-\_\-cseries()}, \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}, and \hyperlink{polyutils_8py_source_l00085}{pyneb.\-utils.\-polyutils.\-trimseq()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00676}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a20beb101adf242958f21dff04591e1ca}{00676} 
00677 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a20beb101adf242958f21dff04591e1ca}{chebmul}(c1, c2):
00678     \textcolor{stringliteral}{"""}
00679 \textcolor{stringliteral}{    Multiply one Chebyshev series by another.}
00680 \textcolor{stringliteral}{}
00681 \textcolor{stringliteral}{    Returns the product of two Chebyshev series `c1` * `c2`.  The arguments}
00682 \textcolor{stringliteral}{    are sequences of coefficients, from lowest order "term" to highest,}
00683 \textcolor{stringliteral}{    e.g., [1,2,3] represents the series ``T\_0 + 2*T\_1 + 3*T\_2``.}
00684 \textcolor{stringliteral}{}
00685 \textcolor{stringliteral}{    Parameters}
00686 \textcolor{stringliteral}{    ----------}
00687 \textcolor{stringliteral}{    c1, c2 : array\_like}
00688 \textcolor{stringliteral}{        1-d arrays of Chebyshev series coefficients ordered from low to}
00689 \textcolor{stringliteral}{        high.}
00690 \textcolor{stringliteral}{}
00691 \textcolor{stringliteral}{    Returns}
00692 \textcolor{stringliteral}{    -------}
00693 \textcolor{stringliteral}{    out : ndarray}
00694 \textcolor{stringliteral}{        Of Chebyshev series coefficients representing their product.}
00695 \textcolor{stringliteral}{}
00696 \textcolor{stringliteral}{    See Also}
00697 \textcolor{stringliteral}{    --------}
00698 \textcolor{stringliteral}{    chebadd, chebsub, chebdiv, chebpow}
00699 \textcolor{stringliteral}{}
00700 \textcolor{stringliteral}{    Notes}
00701 \textcolor{stringliteral}{    -----}
00702 \textcolor{stringliteral}{    In general, the (polynomial) product of two C-series results in terms}
00703 \textcolor{stringliteral}{    that are not in the Chebyshev polynomial basis set.  Thus, to express}
00704 \textcolor{stringliteral}{    the product as a C-series, it is typically necessary to "re-project"}
00705 \textcolor{stringliteral}{    the product onto said basis set, which typically produces}
00706 \textcolor{stringliteral}{    "un-intuitive" (but correct) results; see Examples section below.}
00707 \textcolor{stringliteral}{}
00708 \textcolor{stringliteral}{    Examples}
00709 \textcolor{stringliteral}{    --------}
00710 \textcolor{stringliteral}{    >>> from numpy.polynomial import chebyshev as C}
00711 \textcolor{stringliteral}{    >>> c1 = (1,2,3)}
00712 \textcolor{stringliteral}{    >>> c2 = (3,2,1)}
00713 \textcolor{stringliteral}{    >>> C.chebmul(c1,c2) # multiplication requires "reprojection"}
00714 \textcolor{stringliteral}{    array([  6.5,  12. ,  12. ,   4. ,   1.5])}
00715 \textcolor{stringliteral}{}
00716 \textcolor{stringliteral}{    """}
00717     \textcolor{comment}{# c1, c2 are trimmed copies}
00718     [c1, c2] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([c1, c2])
00719     z1 = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{\_cseries\_to\_zseries}(c1)
00720     z2 = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{\_cseries\_to\_zseries}(c2)
00721     prd = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ac430f61f52899c1e2a276d8b76fa47d5}{\_zseries\_mul}(z1, z2)
00722     ret = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}{\_zseries\_to\_cseries}(prd)
00723     \textcolor{keywordflow}{return} \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{trimseq}(ret)
00724 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a91d78fa31041dfe9ccf7bbc0891809b3}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebmulx@{chebmulx}}
\index{chebmulx@{chebmulx}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebmulx}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebmulx (
\begin{DoxyParamCaption}
\item[{}]{cs}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a91d78fa31041dfe9ccf7bbc0891809b3}
\begin{DoxyVerb}Multiply a Chebyshev series by x.

Multiply the polynomial `cs` by x, where x is the independent
variable.


Parameters
----------
cs : array_like
    1-d array of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----
.. versionadded:: 1.5.0\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00637}{637} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}.



Referenced by \hyperlink{chebyshev_8py_source_l00472}{pyneb.\-utils.\-chebyshev.\-chebfromroots()}, and \hyperlink{chebyshev_8py_source_l00309}{pyneb.\-utils.\-chebyshev.\-poly2cheb()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00637}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a91d78fa31041dfe9ccf7bbc0891809b3}{00637} 
00638 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a91d78fa31041dfe9ccf7bbc0891809b3}{chebmulx}(cs):
00639     \textcolor{stringliteral}{"""Multiply a Chebyshev series by x.}
00640 \textcolor{stringliteral}{}
00641 \textcolor{stringliteral}{    Multiply the polynomial `cs` by x, where x is the independent}
00642 \textcolor{stringliteral}{    variable.}
00643 \textcolor{stringliteral}{}
00644 \textcolor{stringliteral}{}
00645 \textcolor{stringliteral}{    Parameters}
00646 \textcolor{stringliteral}{    ----------}
00647 \textcolor{stringliteral}{    cs : array\_like}
00648 \textcolor{stringliteral}{        1-d array of Chebyshev series coefficients ordered from low to}
00649 \textcolor{stringliteral}{        high.}
00650 \textcolor{stringliteral}{}
00651 \textcolor{stringliteral}{    Returns}
00652 \textcolor{stringliteral}{    -------}
00653 \textcolor{stringliteral}{    out : ndarray}
00654 \textcolor{stringliteral}{        Array representing the result of the multiplication.}
00655 \textcolor{stringliteral}{}
00656 \textcolor{stringliteral}{    Notes}
00657 \textcolor{stringliteral}{    -----}
00658 \textcolor{stringliteral}{    .. versionadded:: 1.5.0}
00659 \textcolor{stringliteral}{}
00660 \textcolor{stringliteral}{    """}
00661     \textcolor{comment}{# cs is a trimmed copy}
00662     [cs] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([cs])
00663     \textcolor{comment}{# The zero series needs special treatment}
00664     \textcolor{keywordflow}{if} len(cs) == 1 \textcolor{keywordflow}{and} cs[0] == 0:
00665         \textcolor{keywordflow}{return} cs
00666 
00667     prd = np.empty(len(cs) + 1, dtype=cs.dtype)
00668     prd[0] = cs[0]*0
00669     prd[1] = cs[0]
00670     \textcolor{keywordflow}{if} len(cs) > 1:
00671         tmp = cs[1:]/2
00672         prd[2:] = tmp
00673         prd[0:-2] += tmp
00674     \textcolor{keywordflow}{return} prd
00675 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_ab647ff3aa7750a09b934b98cddd4c90d}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebpow@{chebpow}}
\index{chebpow@{chebpow}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebpow}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebpow (
\begin{DoxyParamCaption}
\item[{}]{cs, }
\item[{}]{pow, }
\item[{}]{maxpower = {\ttfamily 16}}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_ab647ff3aa7750a09b934b98cddd4c90d}
\begin{DoxyVerb}Raise a Chebyshev series to a power.

Returns the Chebyshev series `cs` raised to the power `pow`. The
arguement `cs` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``T_0 + 2*T_1 + 3*T_2.``

Parameters
----------
cs : array_like
    1d array of chebyshev series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to umanageable size. Default is 16

Returns
-------
coef : ndarray
    Chebyshev series of power.

See Also
--------
chebadd, chebsub, chebmul, chebdiv

Examples
--------\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00790}{790} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{chebyshev_8py_source_l00100}{pyneb.\-utils.\-chebyshev.\-\_\-cseries\-\_\-to\-\_\-zseries()}, \hyperlink{chebyshev_8py_source_l00124}{pyneb.\-utils.\-chebyshev.\-\_\-zseries\-\_\-to\-\_\-cseries()}, and \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00790}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ab647ff3aa7750a09b934b98cddd4c90d}{00790} 
00791 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_ab647ff3aa7750a09b934b98cddd4c90d}{chebpow}(cs, pow, maxpower=16) :
00792     \textcolor{stringliteral}{"""Raise a Chebyshev series to a power.}
00793 \textcolor{stringliteral}{}
00794 \textcolor{stringliteral}{    Returns the Chebyshev series `cs` raised to the power `pow`. The}
00795 \textcolor{stringliteral}{    arguement `cs` is a sequence of coefficients ordered from low to high.}
00796 \textcolor{stringliteral}{    i.e., [1,2,3] is the series  ``T\_0 + 2*T\_1 + 3*T\_2.``}
00797 \textcolor{stringliteral}{}
00798 \textcolor{stringliteral}{    Parameters}
00799 \textcolor{stringliteral}{    ----------}
00800 \textcolor{stringliteral}{    cs : array\_like}
00801 \textcolor{stringliteral}{        1d array of chebyshev series coefficients ordered from low to}
00802 \textcolor{stringliteral}{        high.}
00803 \textcolor{stringliteral}{    pow : integer}
00804 \textcolor{stringliteral}{        Power to which the series will be raised}
00805 \textcolor{stringliteral}{    maxpower : integer, optional}
00806 \textcolor{stringliteral}{        Maximum power allowed. This is mainly to limit growth of the series}
00807 \textcolor{stringliteral}{        to umanageable size. Default is 16}
00808 \textcolor{stringliteral}{}
00809 \textcolor{stringliteral}{    Returns}
00810 \textcolor{stringliteral}{    -------}
00811 \textcolor{stringliteral}{    coef : ndarray}
00812 \textcolor{stringliteral}{        Chebyshev series of power.}
00813 \textcolor{stringliteral}{}
00814 \textcolor{stringliteral}{    See Also}
00815 \textcolor{stringliteral}{    --------}
00816 \textcolor{stringliteral}{    chebadd, chebsub, chebmul, chebdiv}
00817 \textcolor{stringliteral}{}
00818 \textcolor{stringliteral}{    Examples}
00819 \textcolor{stringliteral}{    --------}
00820 \textcolor{stringliteral}{}
00821 \textcolor{stringliteral}{    """}
00822     \textcolor{comment}{# cs is a trimmed copy}
00823     [cs] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([cs])
00824     power = int(pow)
00825     \textcolor{keywordflow}{if} power != pow \textcolor{keywordflow}{or} power < 0 :
00826         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"Power must be a non-negative integer."})
00827     \textcolor{keywordflow}{elif} maxpower \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} power > maxpower :
00828         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"Power is too large"})
00829     \textcolor{keywordflow}{elif} power == 0 :
00830         \textcolor{keywordflow}{return} np.array([1], dtype=cs.dtype)
00831     \textcolor{keywordflow}{elif} power == 1 :
00832         \textcolor{keywordflow}{return} cs
00833     \textcolor{keywordflow}{else} :
00834         \textcolor{comment}{# This can be made more efficient by using powers of two}
00835         \textcolor{comment}{# in the usual way.}
00836         zs = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a3340d022485b954c9c722b6eaa456ebb}{\_cseries\_to\_zseries}(cs)
00837         prd = zs
00838         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(2, power + 1) :
00839             prd = np.convolve(prd, zs)
00840         \textcolor{keywordflow}{return} \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa21c9418f1740d12b80ab1563f49ce0b}{\_zseries\_to\_cseries}(prd)

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_aa5e7d5d318e547f5df15b55224524753}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebpts1@{chebpts1}}
\index{chebpts1@{chebpts1}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebpts1}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebpts1 (
\begin{DoxyParamCaption}
\item[{}]{npts}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_aa5e7d5d318e547f5df15b55224524753}
\begin{DoxyVerb}Chebyshev points of the first kind.

Chebyshev points of the first kind are the set ``{cos(x_k)}``,
where ``x_k = pi*(k + .5)/npts`` for k in ``range(npts}``.

Parameters
----------
npts : int
    Number of sample points desired.

Returns
-------
pts : ndarray
    The Chebyshev points of the second kind.

Notes
-----
.. versionadded:: 1.5.0\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l01340}{1340} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l01340}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa5e7d5d318e547f5df15b55224524753}{01340} 
01341 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aa5e7d5d318e547f5df15b55224524753}{chebpts1}(npts):
01342     \textcolor{stringliteral}{"""Chebyshev points of the first kind.}
01343 \textcolor{stringliteral}{}
01344 \textcolor{stringliteral}{    Chebyshev points of the first kind are the set ``\{cos(x\_k)\}``,}
01345 \textcolor{stringliteral}{    where ``x\_k = pi*(k + .5)/npts`` for k in ``range(npts\}``.}
01346 \textcolor{stringliteral}{}
01347 \textcolor{stringliteral}{    Parameters}
01348 \textcolor{stringliteral}{    ----------}
01349 \textcolor{stringliteral}{    npts : int}
01350 \textcolor{stringliteral}{        Number of sample points desired.}
01351 \textcolor{stringliteral}{}
01352 \textcolor{stringliteral}{    Returns}
01353 \textcolor{stringliteral}{    -------}
01354 \textcolor{stringliteral}{    pts : ndarray}
01355 \textcolor{stringliteral}{        The Chebyshev points of the second kind.}
01356 \textcolor{stringliteral}{}
01357 \textcolor{stringliteral}{    Notes}
01358 \textcolor{stringliteral}{    -----}
01359 \textcolor{stringliteral}{    .. versionadded:: 1.5.0}
01360 \textcolor{stringliteral}{}
01361 \textcolor{stringliteral}{    """}
01362     \_npts = int(npts)
01363     \textcolor{keywordflow}{if} \_npts != npts:
01364         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"npts must be integer"})
01365     \textcolor{keywordflow}{if} \_npts < 1:
01366         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"npts must be >= 1"})
01367 
01368     x = np.linspace(-np.pi, 0, \_npts, endpoint=\textcolor{keyword}{False}) + np.pi/(2*\_npts)
01369     \textcolor{keywordflow}{return} np.cos(x)
01370 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a375236ee9f8b4a3f0d7d099af19e7818}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebpts2@{chebpts2}}
\index{chebpts2@{chebpts2}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebpts2}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebpts2 (
\begin{DoxyParamCaption}
\item[{}]{npts}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a375236ee9f8b4a3f0d7d099af19e7818}
\begin{DoxyVerb}Chebyshev points of the second kind.

Chebyshev points of the second kind are the set ``{cos(x_k)}``,
where ``x_k = pi*/(npts - 1)`` for k in ``range(npts}``.

Parameters
----------
npts : int
    Number of sample points desired.

Returns
-------
pts : ndarray
    The Chebyshev points of the second kind.

Notes
-----
.. versionadded:: 1.5.0\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l01371}{1371} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l01371}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a375236ee9f8b4a3f0d7d099af19e7818}{01371} 
01372 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a375236ee9f8b4a3f0d7d099af19e7818}{chebpts2}(npts):
01373     \textcolor{stringliteral}{"""Chebyshev points of the second kind.}
01374 \textcolor{stringliteral}{}
01375 \textcolor{stringliteral}{    Chebyshev points of the second kind are the set ``\{cos(x\_k)\}``,}
01376 \textcolor{stringliteral}{    where ``x\_k = pi*/(npts - 1)`` for k in ``range(npts\}``.}
01377 \textcolor{stringliteral}{}
01378 \textcolor{stringliteral}{    Parameters}
01379 \textcolor{stringliteral}{    ----------}
01380 \textcolor{stringliteral}{    npts : int}
01381 \textcolor{stringliteral}{        Number of sample points desired.}
01382 \textcolor{stringliteral}{}
01383 \textcolor{stringliteral}{    Returns}
01384 \textcolor{stringliteral}{    -------}
01385 \textcolor{stringliteral}{    pts : ndarray}
01386 \textcolor{stringliteral}{        The Chebyshev points of the second kind.}
01387 \textcolor{stringliteral}{}
01388 \textcolor{stringliteral}{    Notes}
01389 \textcolor{stringliteral}{    -----}
01390 \textcolor{stringliteral}{    .. versionadded:: 1.5.0}
01391 \textcolor{stringliteral}{}
01392 \textcolor{stringliteral}{    """}
01393     \_npts = int(npts)
01394     \textcolor{keywordflow}{if} \_npts != npts:
01395         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"npts must be integer"})
01396     \textcolor{keywordflow}{if} \_npts < 2:
01397         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"npts must be >= 2"})
01398 
01399     x = np.linspace(-np.pi, 0, \_npts)
01400     \textcolor{keywordflow}{return} np.cos(x)
01401 
01402 
01403 \textcolor{comment}{#}
01404 \textcolor{comment}{# Chebyshev series class}
01405 \textcolor{comment}{#}
01406 
01407 exec(polytemplate.substitute(name=\textcolor{stringliteral}{'Chebyshev'}, nick=\textcolor{stringliteral}{'cheb'}, domain=\textcolor{stringliteral}{'[-1,1]'}))
\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a63ef136648aeceebc5b0a0cfce98d49a}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebroots@{chebroots}}
\index{chebroots@{chebroots}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebroots}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebroots (
\begin{DoxyParamCaption}
\item[{}]{cs}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a63ef136648aeceebc5b0a0cfce98d49a}
\begin{DoxyVerb}Compute the roots of a Chebyshev series.

Return the roots (a.k.a "zeros") of the C-series represented by `cs`,
which is the sequence of the C-series' coefficients from lowest order
"term" to highest, e.g., [1,2,3] represents the C-series
``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
cs : array_like
    1-d array of C-series coefficients ordered from low to high.

Returns
-------
out : ndarray
    Array of the roots.  If all the roots are real, then so is the
    dtype of ``out``; otherwise, ``out``'s dtype is complex.

See Also
--------
polyroots

Notes
-----
Algorithm(s) used:

Remember: because the C-series basis set is different from the
"standard" basis set, the results of this function *may* not be what
one is expecting.

Examples
--------
>>> import numpy.polynomial as P
>>> import numpy.polynomial.chebyshev as C
>>> P.polyroots((-1,1,-1,1)) # x^3 - x^2 + x - 1 has two complex roots
array([ -4.99600361e-16-1.j,  -4.99600361e-16+1.j,   1.00000e+00+0.j])
>>> C.chebroots((-1,1,-1,1)) # T3 - T2 + T1 - T0 has only real roots
array([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00])\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l01276}{1276} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l01276}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a63ef136648aeceebc5b0a0cfce98d49a}{01276} 
01277 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a63ef136648aeceebc5b0a0cfce98d49a}{chebroots}(cs):
01278     \textcolor{stringliteral}{"""}
01279 \textcolor{stringliteral}{    Compute the roots of a Chebyshev series.}
01280 \textcolor{stringliteral}{}
01281 \textcolor{stringliteral}{    Return the roots (a.k.a "zeros") of the C-series represented by `cs`,}
01282 \textcolor{stringliteral}{    which is the sequence of the C-series' coefficients from lowest order}
01283 \textcolor{stringliteral}{    "term" to highest, e.g., [1,2,3] represents the C-series}
01284 \textcolor{stringliteral}{    ``T\_0 + 2*T\_1 + 3*T\_2``.}
01285 \textcolor{stringliteral}{}
01286 \textcolor{stringliteral}{    Parameters}
01287 \textcolor{stringliteral}{    ----------}
01288 \textcolor{stringliteral}{    cs : array\_like}
01289 \textcolor{stringliteral}{        1-d array of C-series coefficients ordered from low to high.}
01290 \textcolor{stringliteral}{}
01291 \textcolor{stringliteral}{    Returns}
01292 \textcolor{stringliteral}{    -------}
01293 \textcolor{stringliteral}{    out : ndarray}
01294 \textcolor{stringliteral}{        Array of the roots.  If all the roots are real, then so is the}
01295 \textcolor{stringliteral}{        dtype of ``out``; otherwise, ``out``'s dtype is complex.}
01296 \textcolor{stringliteral}{}
01297 \textcolor{stringliteral}{    See Also}
01298 \textcolor{stringliteral}{    --------}
01299 \textcolor{stringliteral}{    polyroots}
01300 \textcolor{stringliteral}{}
01301 \textcolor{stringliteral}{    Notes}
01302 \textcolor{stringliteral}{    -----}
01303 \textcolor{stringliteral}{    Algorithm(s) used:}
01304 \textcolor{stringliteral}{}
01305 \textcolor{stringliteral}{    Remember: because the C-series basis set is different from the}
01306 \textcolor{stringliteral}{    "standard" basis set, the results of this function *may* not be what}
01307 \textcolor{stringliteral}{    one is expecting.}
01308 \textcolor{stringliteral}{}
01309 \textcolor{stringliteral}{    Examples}
01310 \textcolor{stringliteral}{    --------}
01311 \textcolor{stringliteral}{    >>> import numpy.polynomial as P}
01312 \textcolor{stringliteral}{    >>> import numpy.polynomial.chebyshev as C}
01313 \textcolor{stringliteral}{    >>> P.polyroots((-1,1,-1,1)) # x^3 - x^2 + x - 1 has two complex roots}
01314 \textcolor{stringliteral}{    array([ -4.99600361e-16-1.j,  -4.99600361e-16+1.j,   1.00000e+00+0.j])}
01315 \textcolor{stringliteral}{    >>> C.chebroots((-1,1,-1,1)) # T3 - T2 + T1 - T0 has only real roots}
01316 \textcolor{stringliteral}{    array([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00])}
01317 \textcolor{stringliteral}{}
01318 \textcolor{stringliteral}{    """}
01319     \textcolor{comment}{# cs is a trimmed copy}
01320     [cs] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([cs])
01321     \textcolor{keywordflow}{if} len(cs) <= 1 :
01322         \textcolor{keywordflow}{return} np.array([], dtype=cs.dtype)
01323     \textcolor{keywordflow}{if} len(cs) == 2 :
01324         \textcolor{keywordflow}{return} np.array([-cs[0]/cs[1]])
01325 
01326     n = len(cs) - 1
01327     cs /= cs[-1]
01328     cmat = np.zeros((n,n), dtype=cs.dtype)
01329     cmat[1, 0] = 1
01330     \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(1, n):
01331         cmat[i - 1, i] = .5
01332         \textcolor{keywordflow}{if} i != n - 1:
01333             cmat[i + 1, i] = .5
01334         \textcolor{keywordflow}{else}:
01335             cmat[:, i] -= cs[:-1]*.5
01336     roots = la.eigvals(cmat)
01337     roots.sort()
01338     \textcolor{keywordflow}{return} roots
01339 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a2ca3ca3bac02e30625edb4c48ada7ddf}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebsub@{chebsub}}
\index{chebsub@{chebsub}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebsub}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebsub (
\begin{DoxyParamCaption}
\item[{}]{c1, }
\item[{}]{c2}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a2ca3ca3bac02e30625edb4c48ada7ddf}
\begin{DoxyVerb}Subtract one Chebyshev series from another.

Returns the difference of two Chebyshev series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-d arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Chebyshev series coefficients representing their difference.

See Also
--------
chebadd, chebmul, chebdiv, chebpow

Notes
-----
Unlike multiplication, division, etc., the difference of two Chebyshev
series is a Chebyshev series (without having to "reproject" the result
onto the basis set) so subtraction, just like that of "standard"
polynomials, is simply "component-wise."

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> C.chebsub(c1,c2)
array([-2.,  0.,  2.])
>>> C.chebsub(c2,c1) # -C.chebsub(c1,c2)
array([ 2.,  0., -2.])\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00584}{584} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}, and \hyperlink{polyutils_8py_source_l00085}{pyneb.\-utils.\-polyutils.\-trimseq()}.



Referenced by \hyperlink{chebyshev_8py_source_l00472}{pyneb.\-utils.\-chebyshev.\-chebfromroots()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00584}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a2ca3ca3bac02e30625edb4c48ada7ddf}{00584} 
00585 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a2ca3ca3bac02e30625edb4c48ada7ddf}{chebsub}(c1, c2):
00586     \textcolor{stringliteral}{"""}
00587 \textcolor{stringliteral}{    Subtract one Chebyshev series from another.}
00588 \textcolor{stringliteral}{}
00589 \textcolor{stringliteral}{    Returns the difference of two Chebyshev series `c1` - `c2`.  The}
00590 \textcolor{stringliteral}{    sequences of coefficients are from lowest order term to highest, i.e.,}
00591 \textcolor{stringliteral}{    [1,2,3] represents the series ``T\_0 + 2*T\_1 + 3*T\_2``.}
00592 \textcolor{stringliteral}{}
00593 \textcolor{stringliteral}{    Parameters}
00594 \textcolor{stringliteral}{    ----------}
00595 \textcolor{stringliteral}{    c1, c2 : array\_like}
00596 \textcolor{stringliteral}{        1-d arrays of Chebyshev series coefficients ordered from low to}
00597 \textcolor{stringliteral}{        high.}
00598 \textcolor{stringliteral}{}
00599 \textcolor{stringliteral}{    Returns}
00600 \textcolor{stringliteral}{    -------}
00601 \textcolor{stringliteral}{    out : ndarray}
00602 \textcolor{stringliteral}{        Of Chebyshev series coefficients representing their difference.}
00603 \textcolor{stringliteral}{}
00604 \textcolor{stringliteral}{    See Also}
00605 \textcolor{stringliteral}{    --------}
00606 \textcolor{stringliteral}{    chebadd, chebmul, chebdiv, chebpow}
00607 \textcolor{stringliteral}{}
00608 \textcolor{stringliteral}{    Notes}
00609 \textcolor{stringliteral}{    -----}
00610 \textcolor{stringliteral}{    Unlike multiplication, division, etc., the difference of two Chebyshev}
00611 \textcolor{stringliteral}{    series is a Chebyshev series (without having to "reproject" the result}
00612 \textcolor{stringliteral}{    onto the basis set) so subtraction, just like that of "standard"}
00613 \textcolor{stringliteral}{    polynomials, is simply "component-wise."}
00614 \textcolor{stringliteral}{}
00615 \textcolor{stringliteral}{    Examples}
00616 \textcolor{stringliteral}{    --------}
00617 \textcolor{stringliteral}{    >>> from numpy.polynomial import chebyshev as C}
00618 \textcolor{stringliteral}{    >>> c1 = (1,2,3)}
00619 \textcolor{stringliteral}{    >>> c2 = (3,2,1)}
00620 \textcolor{stringliteral}{    >>> C.chebsub(c1,c2)}
00621 \textcolor{stringliteral}{    array([-2.,  0.,  2.])}
00622 \textcolor{stringliteral}{    >>> C.chebsub(c2,c1) # -C.chebsub(c1,c2)}
00623 \textcolor{stringliteral}{    array([ 2.,  0., -2.])}
00624 \textcolor{stringliteral}{}
00625 \textcolor{stringliteral}{    """}
00626     \textcolor{comment}{# c1, c2 are trimmed copies}
00627     [c1, c2] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([c1, c2])
00628     \textcolor{keywordflow}{if} len(c1) > len(c2) :
00629         c1[:c2.size] -= c2
00630         ret = c1
00631     \textcolor{keywordflow}{else} :
00632         c2 = -c2
00633         c2[:c1.size] += c1
00634         ret = c2
00635     \textcolor{keywordflow}{return} \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{trimseq}(ret)
00636 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a44ae40c5b4cbdc3a230c014c834f5ce6}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebval@{chebval}}
\index{chebval@{chebval}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebval}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebval (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{cs}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a44ae40c5b4cbdc3a230c014c834f5ce6}
\begin{DoxyVerb}Evaluate a Chebyshev series.

If `cs` is of length `n`, this function returns :

``p(x) = cs[0]*T_0(x) + cs[1]*T_1(x) + ... + cs[n-1]*T_{n-1}(x)``

If x is a sequence or array then p(x) will have the same shape as x.
If r is a ring_like object that supports multiplication and addition
by the values in `cs`, then an object of the same type is returned.

Parameters
----------
x : array_like, ring_like
    Array of numbers or objects that support multiplication and
    addition with themselves and with the elements of `cs`.
cs : array_like
    1-d array of Chebyshev coefficients ordered from low to high.

Returns
-------
values : ndarray, ring_like
    If the return is an ndarray then it has the same shape as `x`.

See Also
--------
chebfit

Examples
--------

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l01018}{1018} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}.



Referenced by \hyperlink{chebyshev_8py_source_l00912}{pyneb.\-utils.\-chebyshev.\-chebint()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l01018}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a44ae40c5b4cbdc3a230c014c834f5ce6}{01018} 
01019 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a44ae40c5b4cbdc3a230c014c834f5ce6}{chebval}(x, cs):
01020     \textcolor{stringliteral}{"""Evaluate a Chebyshev series.}
01021 \textcolor{stringliteral}{}
01022 \textcolor{stringliteral}{    If `cs` is of length `n`, this function returns :}
01023 \textcolor{stringliteral}{}
01024 \textcolor{stringliteral}{    ``p(x) = cs[0]*T\_0(x) + cs[1]*T\_1(x) + ... + cs[n-1]*T\_\{n-1\}(x)``}
01025 \textcolor{stringliteral}{}
01026 \textcolor{stringliteral}{    If x is a sequence or array then p(x) will have the same shape as x.}
01027 \textcolor{stringliteral}{    If r is a ring\_like object that supports multiplication and addition}
01028 \textcolor{stringliteral}{    by the values in `cs`, then an object of the same type is returned.}
01029 \textcolor{stringliteral}{}
01030 \textcolor{stringliteral}{    Parameters}
01031 \textcolor{stringliteral}{    ----------}
01032 \textcolor{stringliteral}{    x : array\_like, ring\_like}
01033 \textcolor{stringliteral}{        Array of numbers or objects that support multiplication and}
01034 \textcolor{stringliteral}{        addition with themselves and with the elements of `cs`.}
01035 \textcolor{stringliteral}{    cs : array\_like}
01036 \textcolor{stringliteral}{        1-d array of Chebyshev coefficients ordered from low to high.}
01037 \textcolor{stringliteral}{}
01038 \textcolor{stringliteral}{    Returns}
01039 \textcolor{stringliteral}{    -------}
01040 \textcolor{stringliteral}{    values : ndarray, ring\_like}
01041 \textcolor{stringliteral}{        If the return is an ndarray then it has the same shape as `x`.}
01042 \textcolor{stringliteral}{}
01043 \textcolor{stringliteral}{    See Also}
01044 \textcolor{stringliteral}{    --------}
01045 \textcolor{stringliteral}{    chebfit}
01046 \textcolor{stringliteral}{}
01047 \textcolor{stringliteral}{    Examples}
01048 \textcolor{stringliteral}{    --------}
01049 \textcolor{stringliteral}{}
01050 \textcolor{stringliteral}{    Notes}
01051 \textcolor{stringliteral}{    -----}
01052 \textcolor{stringliteral}{    The evaluation uses Clenshaw recursion, aka synthetic division.}
01053 \textcolor{stringliteral}{}
01054 \textcolor{stringliteral}{    Examples}
01055 \textcolor{stringliteral}{    --------}
01056 \textcolor{stringliteral}{}
01057 \textcolor{stringliteral}{    """}
01058     \textcolor{comment}{# cs is a trimmed copy}
01059     [cs] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([cs])
01060     \textcolor{keywordflow}{if} isinstance(x, tuple) \textcolor{keywordflow}{or} isinstance(x, list) :
01061         x = np.asarray(x)
01062 
01063     \textcolor{keywordflow}{if} len(cs) == 1 :
01064         c0 = cs[0]
01065         c1 = 0
01066     \textcolor{keywordflow}{elif} len(cs) == 2 :
01067         c0 = cs[0]
01068         c1 = cs[1]
01069     \textcolor{keywordflow}{else} :
01070         x2 = 2*x
01071         c0 = cs[-2]
01072         c1 = cs[-1]
01073         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(3, len(cs) + 1) :
01074             tmp = c0
01075             c0 = cs[-i] - c1
01076             c1 = tmp + c1*x2
01077     \textcolor{keywordflow}{return} c0 + c1*x

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a4a53ad781fcf149c5ab6ae5d021b0950}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebvander@{chebvander}}
\index{chebvander@{chebvander}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebvander}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-chebvander (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{deg}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_a4a53ad781fcf149c5ab6ae5d021b0950}
\begin{DoxyVerb}Vandermonde matrix of given degree.

Returns the Vandermonde matrix of degree `deg` and sample points `x`.
This isn't a true Vandermonde matrix because `x` can be an arbitrary
ndarray and the Chebyshev polynomials aren't powers. If ``V`` is the
returned matrix and `x` is a 2d array, then the elements of ``V`` are
``V[i,j,k] = T_k(x[i,j])``, where ``T_k`` is the Chebyshev polynomial
of degree ``k``.

Parameters
----------
x : array_like
    Array of points. The values are converted to double or complex
    doubles. If x is scalar it is converted to a 1D array.
deg : integer
    Degree of the resulting matrix.

Returns
-------
vander : Vandermonde matrix.
    The shape of the returned matrix is ``x.shape + (deg+1,)``. The last
    index is the degree.\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l01078}{1078} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



Referenced by \hyperlink{chebyshev_8py_source_l01121}{pyneb.\-utils.\-chebyshev.\-chebfit()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l01078}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a4a53ad781fcf149c5ab6ae5d021b0950}{01078} 
01079 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a4a53ad781fcf149c5ab6ae5d021b0950}{chebvander}(x, deg) :
01080     \textcolor{stringliteral}{"""Vandermonde matrix of given degree.}
01081 \textcolor{stringliteral}{}
01082 \textcolor{stringliteral}{    Returns the Vandermonde matrix of degree `deg` and sample points `x`.}
01083 \textcolor{stringliteral}{    This isn't a true Vandermonde matrix because `x` can be an arbitrary}
01084 \textcolor{stringliteral}{    ndarray and the Chebyshev polynomials aren't powers. If ``V`` is the}
01085 \textcolor{stringliteral}{    returned matrix and `x` is a 2d array, then the elements of ``V`` are}
01086 \textcolor{stringliteral}{    ``V[i,j,k] = T\_k(x[i,j])``, where ``T\_k`` is the Chebyshev polynomial}
01087 \textcolor{stringliteral}{    of degree ``k``.}
01088 \textcolor{stringliteral}{}
01089 \textcolor{stringliteral}{    Parameters}
01090 \textcolor{stringliteral}{    ----------}
01091 \textcolor{stringliteral}{    x : array\_like}
01092 \textcolor{stringliteral}{        Array of points. The values are converted to double or complex}
01093 \textcolor{stringliteral}{        doubles. If x is scalar it is converted to a 1D array.}
01094 \textcolor{stringliteral}{    deg : integer}
01095 \textcolor{stringliteral}{        Degree of the resulting matrix.}
01096 \textcolor{stringliteral}{}
01097 \textcolor{stringliteral}{    Returns}
01098 \textcolor{stringliteral}{    -------}
01099 \textcolor{stringliteral}{    vander : Vandermonde matrix.}
01100 \textcolor{stringliteral}{        The shape of the returned matrix is ``x.shape + (deg+1,)``. The last}
01101 \textcolor{stringliteral}{        index is the degree.}
01102 \textcolor{stringliteral}{}
01103 \textcolor{stringliteral}{    """}
01104     ideg = int(deg)
01105     \textcolor{keywordflow}{if} ideg != deg:
01106         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"deg must be integer"})
01107     \textcolor{keywordflow}{if} ideg < 0:
01108         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"deg must be non-negative"})
01109 
01110     x = np.array(x, copy=0, ndmin=1) + 0.0
01111     v = np.empty((ideg + 1,) + x.shape, dtype=x.dtype)
01112     \textcolor{comment}{# Use forward recursion to generate the entries.}
01113     v[0] = x*0 + 1
01114     \textcolor{keywordflow}{if} ideg > 0 :
01115         x2 = 2*x
01116         v[1] = x
01117         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(2, ideg + 1) :
01118             v[i] = v[i-1]*x2 - v[i-2]
01119     \textcolor{keywordflow}{return} np.rollaxis(v, 0, v.ndim)
01120 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_abd824b0c3e5e2cc0f9464a0986dc3819}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!poly2cheb@{poly2cheb}}
\index{poly2cheb@{poly2cheb}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{poly2cheb}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-chebyshev.\-poly2cheb (
\begin{DoxyParamCaption}
\item[{}]{pol}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1chebyshev_abd824b0c3e5e2cc0f9464a0986dc3819}
\begin{DoxyVerb}Convert a polynomial to a Chebyshev series.

Convert an array representing the coefficients of a polynomial (relative
to the "standard" basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Chebyshev series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-d array containing the polynomial coefficients

Returns
-------
cs : ndarray
    1-d array containing the coefficients of the equivalent Chebyshev
    series.

See Also
--------
cheb2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy import polynomial as P
>>> p = P.Polynomial(range(4))
>>> p
Polynomial([ 0.,  1.,  2.,  3.], [-1.,  1.])
>>> c = p.convert(kind=P.Chebyshev)
>>> c
Chebyshev([ 1.  ,  3.25,  1.  ,  0.75], [-1.,  1.])
>>> P.poly2cheb(range(4))
array([ 1.  ,  3.25,  1.  ,  0.75])\end{DoxyVerb}
 

Definition at line \hyperlink{chebyshev_8py_source_l00309}{309} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.



References \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}, \hyperlink{chebyshev_8py_source_l00534}{pyneb.\-utils.\-chebyshev.\-chebadd()}, and \hyperlink{chebyshev_8py_source_l00637}{pyneb.\-utils.\-chebyshev.\-chebmulx()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00309}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_abd824b0c3e5e2cc0f9464a0986dc3819}{00309} 
00310 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_abd824b0c3e5e2cc0f9464a0986dc3819}{poly2cheb}(pol) :
00311     \textcolor{stringliteral}{"""}
00312 \textcolor{stringliteral}{    Convert a polynomial to a Chebyshev series.}
00313 \textcolor{stringliteral}{}
00314 \textcolor{stringliteral}{    Convert an array representing the coefficients of a polynomial (relative}
00315 \textcolor{stringliteral}{    to the "standard" basis) ordered from lowest degree to highest, to an}
00316 \textcolor{stringliteral}{    array of the coefficients of the equivalent Chebyshev series, ordered}
00317 \textcolor{stringliteral}{    from lowest to highest degree.}
00318 \textcolor{stringliteral}{}
00319 \textcolor{stringliteral}{    Parameters}
00320 \textcolor{stringliteral}{    ----------}
00321 \textcolor{stringliteral}{    pol : array\_like}
00322 \textcolor{stringliteral}{        1-d array containing the polynomial coefficients}
00323 \textcolor{stringliteral}{}
00324 \textcolor{stringliteral}{    Returns}
00325 \textcolor{stringliteral}{    -------}
00326 \textcolor{stringliteral}{    cs : ndarray}
00327 \textcolor{stringliteral}{        1-d array containing the coefficients of the equivalent Chebyshev}
00328 \textcolor{stringliteral}{        series.}
00329 \textcolor{stringliteral}{}
00330 \textcolor{stringliteral}{    See Also}
00331 \textcolor{stringliteral}{    --------}
00332 \textcolor{stringliteral}{    cheb2poly}
00333 \textcolor{stringliteral}{}
00334 \textcolor{stringliteral}{    Notes}
00335 \textcolor{stringliteral}{    -----}
00336 \textcolor{stringliteral}{    The easy way to do conversions between polynomial basis sets}
00337 \textcolor{stringliteral}{    is to use the convert method of a class instance.}
00338 \textcolor{stringliteral}{}
00339 \textcolor{stringliteral}{    Examples}
00340 \textcolor{stringliteral}{    --------}
00341 \textcolor{stringliteral}{    >>> from numpy import polynomial as P}
00342 \textcolor{stringliteral}{    >>> p = P.Polynomial(range(4))}
00343 \textcolor{stringliteral}{    >>> p}
00344 \textcolor{stringliteral}{    Polynomial([ 0.,  1.,  2.,  3.], [-1.,  1.])}
00345 \textcolor{stringliteral}{    >>> c = p.convert(kind=P.Chebyshev)}
00346 \textcolor{stringliteral}{    >>> c}
00347 \textcolor{stringliteral}{    Chebyshev([ 1.  ,  3.25,  1.  ,  0.75], [-1.,  1.])}
00348 \textcolor{stringliteral}{    >>> P.poly2cheb(range(4))}
00349 \textcolor{stringliteral}{    array([ 1.  ,  3.25,  1.  ,  0.75])}
00350 \textcolor{stringliteral}{}
00351 \textcolor{stringliteral}{    """}
00352     [pol] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([pol])
00353     deg = len(pol) - 1
00354     res = 0
00355     \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(deg, -1, -1) :
00356         res = \hyperlink{namespacepyneb_1_1utils_1_1chebyshev_aafceea7ad9a5a18707fcf493bcf70457}{chebadd}(\hyperlink{namespacepyneb_1_1utils_1_1chebyshev_a91d78fa31041dfe9ccf7bbc0891809b3}{chebmulx}(res), pol[i])
00357     \textcolor{keywordflow}{return} res
00358 

\end{DoxyCode}


\subsection{Variable Documentation}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a9cb4e1ba55fc61d6dd46d5c6f534edbc}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!\-\_\-\-\_\-all\-\_\-\-\_\-@{\-\_\-\-\_\-all\-\_\-\-\_\-}}
\index{\-\_\-\-\_\-all\-\_\-\-\_\-@{\-\_\-\-\_\-all\-\_\-\-\_\-}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{\-\_\-\-\_\-all\-\_\-\-\_\-}]{\setlength{\rightskip}{0pt plus 5cm}list pyneb.\-utils.\-chebyshev.\-\_\-\-\_\-all\-\_\-\-\_\-}}\label{namespacepyneb_1_1utils_1_1chebyshev_a9cb4e1ba55fc61d6dd46d5c6f534edbc}
{\bfseries Initial value\-:}
\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_l00001}{}\hyperlink{namespacepyneb_1_1utils_1_1chebyshev}{00001} = [\textcolor{stringliteral}{'chebzero'}, \textcolor{stringliteral}{'chebone'}, \textcolor{stringliteral}{'chebx'}, \textcolor{stringliteral}{'chebdomain'}, \textcolor{stringliteral}{'chebline'},
00002         \textcolor{stringliteral}{'chebadd'}, \textcolor{stringliteral}{'chebsub'}, \textcolor{stringliteral}{'chebmulx'}, \textcolor{stringliteral}{'chebmul'}, \textcolor{stringliteral}{'chebdiv'}, \textcolor{stringliteral}{'chebpow'},
00003         \textcolor{stringliteral}{'chebval'}, \textcolor{stringliteral}{'chebder'}, \textcolor{stringliteral}{'chebint'}, \textcolor{stringliteral}{'cheb2poly'}, \textcolor{stringliteral}{'poly2cheb'},
00004         \textcolor{stringliteral}{'chebfromroots'}, \textcolor{stringliteral}{'chebvander'}, \textcolor{stringliteral}{'chebfit'}, \textcolor{stringliteral}{'chebtrim'}, \textcolor{stringliteral}{'chebroots'},
00005         \textcolor{stringliteral}{'chebpts1'}, \textcolor{stringliteral}{'chebpts2'}, \textcolor{stringliteral}{'Chebyshev'}]
\end{DoxyCode}


Definition at line \hyperlink{chebyshev_8py_source_l00081}{81} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.

\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a57e110567544748d0de429d3743d1241}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebdomain@{chebdomain}}
\index{chebdomain@{chebdomain}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebdomain}]{\setlength{\rightskip}{0pt plus 5cm}tuple pyneb.\-utils.\-chebyshev.\-chebdomain = np.\-array(\mbox{[}-\/1,1\mbox{]})}}\label{namespacepyneb_1_1utils_1_1chebyshev_a57e110567544748d0de429d3743d1241}


Definition at line \hyperlink{chebyshev_8py_source_l00426}{426} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.

\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a26a6cedd505a161858435461e1645503}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebone@{chebone}}
\index{chebone@{chebone}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebone}]{\setlength{\rightskip}{0pt plus 5cm}tuple pyneb.\-utils.\-chebyshev.\-chebone = np.\-array(\mbox{[}1\mbox{]})}}\label{namespacepyneb_1_1utils_1_1chebyshev_a26a6cedd505a161858435461e1645503}


Definition at line \hyperlink{chebyshev_8py_source_l00432}{432} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.

\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a66b8c25023851573f25dc418071de82b}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebtrim@{chebtrim}}
\index{chebtrim@{chebtrim}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebtrim}]{\setlength{\rightskip}{0pt plus 5cm}pyneb.\-utils.\-chebyshev.\-chebtrim = trimcoef}}\label{namespacepyneb_1_1utils_1_1chebyshev_a66b8c25023851573f25dc418071de82b}


Definition at line \hyperlink{chebyshev_8py_source_l00093}{93} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.

\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_a00f984b78341cd7920c46d1a6acacc5f}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebx@{chebx}}
\index{chebx@{chebx}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebx}]{\setlength{\rightskip}{0pt plus 5cm}tuple pyneb.\-utils.\-chebyshev.\-chebx = np.\-array(\mbox{[}0,1\mbox{]})}}\label{namespacepyneb_1_1utils_1_1chebyshev_a00f984b78341cd7920c46d1a6acacc5f}


Definition at line \hyperlink{chebyshev_8py_source_l00435}{435} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.

\hypertarget{namespacepyneb_1_1utils_1_1chebyshev_ad707fa9ec865920c2d8eedf6dfedf21c}{\index{pyneb\-::utils\-::chebyshev@{pyneb\-::utils\-::chebyshev}!chebzero@{chebzero}}
\index{chebzero@{chebzero}!pyneb::utils::chebyshev@{pyneb\-::utils\-::chebyshev}}
\subsubsection[{chebzero}]{\setlength{\rightskip}{0pt plus 5cm}tuple pyneb.\-utils.\-chebyshev.\-chebzero = np.\-array(\mbox{[}0\mbox{]})}}\label{namespacepyneb_1_1utils_1_1chebyshev_ad707fa9ec865920c2d8eedf6dfedf21c}


Definition at line \hyperlink{chebyshev_8py_source_l00429}{429} of file \hyperlink{chebyshev_8py_source}{chebyshev.\-py}.

