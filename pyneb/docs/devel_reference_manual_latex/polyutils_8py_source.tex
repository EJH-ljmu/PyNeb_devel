\hypertarget{polyutils_8py}{\section{polyutils.\-py}
\label{polyutils_8py}\index{pyneb/utils/polyutils.\-py@{pyneb/utils/polyutils.\-py}}
}

\begin{DoxyCode}
\hypertarget{polyutils_8py_source_l00001}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils}{00001} \textcolor{stringliteral}{"""}
00002 \textcolor{stringliteral}{Utililty objects for the polynomial modules.}
00003 \textcolor{stringliteral}{}
00004 \textcolor{stringliteral}{This module provides: error and warning objects; a polynomial base class;}
00005 \textcolor{stringliteral}{and some routines used in both the `polynomial` and `chebyshev` modules.}
00006 \textcolor{stringliteral}{}
00007 \textcolor{stringliteral}{Error objects}
00008 \textcolor{stringliteral}{-------------}
00009 \textcolor{stringliteral}{- `PolyError` -- base class for this sub-package's errors.}
00010 \textcolor{stringliteral}{- `PolyDomainError` -- raised when domains are "mismatched."}
00011 \textcolor{stringliteral}{}
00012 \textcolor{stringliteral}{Warning objects}
00013 \textcolor{stringliteral}{---------------}
00014 \textcolor{stringliteral}{- `RankWarning` -- raised by a least-squares fit when a rank-deficient}
00015 \textcolor{stringliteral}{  matrix is encountered.}
00016 \textcolor{stringliteral}{}
00017 \textcolor{stringliteral}{Base class}
00018 \textcolor{stringliteral}{----------}
00019 \textcolor{stringliteral}{- `PolyBase` -- The base class for the `Polynomial` and `Chebyshev`}
00020 \textcolor{stringliteral}{  classes.}
00021 \textcolor{stringliteral}{}
00022 \textcolor{stringliteral}{Functions}
00023 \textcolor{stringliteral}{---------}
00024 \textcolor{stringliteral}{- `as\_series` -- turns a list of array\_likes into 1-D arrays of common}
00025 \textcolor{stringliteral}{  type.}
00026 \textcolor{stringliteral}{- `trimseq` -- removes trailing zeros.}
00027 \textcolor{stringliteral}{- `trimcoef` -- removes trailing coefficients that are less than a given}
00028 \textcolor{stringliteral}{  magnitude (thereby removing the corresponding terms).}
00029 \textcolor{stringliteral}{- `getdomain` -- returns a domain appropriate for a given set of abscissae.}
00030 \textcolor{stringliteral}{- `mapdomain` -- maps points between domains.}
00031 \textcolor{stringliteral}{- `mapparms` -- parameters of the linear map between domains.}
00032 \textcolor{stringliteral}{}
00033 \textcolor{stringliteral}{"""}
00034 \textcolor{keyword}{from} \_\_future\_\_ \textcolor{keyword}{import} division
00035 
\hypertarget{polyutils_8py_source_l00036}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a5e54a45bb5c6fa4444f663a0b0da0e1f}{00036} \_\_all\_\_ = [\textcolor{stringliteral}{'RankWarning'}, \textcolor{stringliteral}{'PolyError'}, \textcolor{stringliteral}{'PolyDomainError'}, \textcolor{stringliteral}{'PolyBase'},
00037            \textcolor{stringliteral}{'as\_series'}, \textcolor{stringliteral}{'trimseq'}, \textcolor{stringliteral}{'trimcoef'}, \textcolor{stringliteral}{'getdomain'}, \textcolor{stringliteral}{'mapdomain'},
00038            \textcolor{stringliteral}{'mapparms'}]
00039 
00040 \textcolor{keyword}{import} warnings
00041 \textcolor{keyword}{import} numpy \textcolor{keyword}{as} np
00042 \textcolor{keyword}{import} sys
00043 
00044 \textcolor{comment}{#}
00045 \textcolor{comment}{# Warnings and Exceptions}
00046 \textcolor{comment}{#}
00047 
\hypertarget{polyutils_8py_source_l00048}{}\hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_rank_warning}{00048} \textcolor{keyword}{class }\hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_rank_warning}{RankWarning}(UserWarning) :
00049     \textcolor{stringliteral}{"""Issued by chebfit when the design matrix is rank deficient."""}
00050     \textcolor{keywordflow}{pass}
00051 
\hypertarget{polyutils_8py_source_l00052}{}\hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_poly_error}{00052} \textcolor{keyword}{class }\hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_poly_error}{PolyError}(Exception) :
00053     \textcolor{stringliteral}{"""Base class for errors in this module."""}
00054     \textcolor{keywordflow}{pass}
00055 
\hypertarget{polyutils_8py_source_l00056}{}\hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_poly_domain_error}{00056} \textcolor{keyword}{class }\hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_poly_domain_error}{PolyDomainError}(\hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_poly_error}{PolyError}) :
00057     \textcolor{stringliteral}{"""Issued by the generic Poly class when two domains don't match.}
00058 \textcolor{stringliteral}{}
00059 \textcolor{stringliteral}{    This is raised when an binary operation is passed Poly objects with}
00060 \textcolor{stringliteral}{    different domains.}
00061 \textcolor{stringliteral}{}
00062 \textcolor{stringliteral}{    """}
00063     \textcolor{keywordflow}{pass}
00064 
00065 \textcolor{comment}{#}
00066 \textcolor{comment}{# Base class for all polynomial types}
00067 \textcolor{comment}{#}
00068 
\hypertarget{polyutils_8py_source_l00069}{}\hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_poly_base}{00069} \textcolor{keyword}{class }\hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_poly_base}{PolyBase}(object) :
00070     \textcolor{keywordflow}{pass}
00071 
00072 \textcolor{comment}{#}
00073 \textcolor{comment}{# We need the any function for python < 2.5}
00074 \textcolor{comment}{#}
00075 \textcolor{keywordflow}{if} sys.version\_info[:2] < (2,5) :
\hypertarget{polyutils_8py_source_l00076}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}{00076}     \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}{any}(iterable) :
00077         \textcolor{keywordflow}{for} element \textcolor{keywordflow}{in} iterable:
00078             \textcolor{keywordflow}{if} element :
00079                 \textcolor{keywordflow}{return} \textcolor{keyword}{True}
00080         \textcolor{keywordflow}{return} \textcolor{keyword}{False}
00081 
00082 \textcolor{comment}{#}
00083 \textcolor{comment}{# Helper functions to convert inputs to 1d arrays}
00084 \textcolor{comment}{#}
\hypertarget{polyutils_8py_source_l00085}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{00085} \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{trimseq}(seq) :
00086     \textcolor{stringliteral}{"""Remove small Poly series coefficients.}
00087 \textcolor{stringliteral}{}
00088 \textcolor{stringliteral}{    Parameters}
00089 \textcolor{stringliteral}{    ----------}
00090 \textcolor{stringliteral}{    seq : sequence}
00091 \textcolor{stringliteral}{        Sequence of Poly series coefficients. This routine fails for}
00092 \textcolor{stringliteral}{        empty sequences.}
00093 \textcolor{stringliteral}{}
00094 \textcolor{stringliteral}{    Returns}
00095 \textcolor{stringliteral}{    -------}
00096 \textcolor{stringliteral}{    series : sequence}
00097 \textcolor{stringliteral}{        Subsequence with trailing zeros removed. If the resulting sequence}
00098 \textcolor{stringliteral}{        would be empty, return the first element. The returned sequence may}
00099 \textcolor{stringliteral}{        or may not be a view.}
00100 \textcolor{stringliteral}{}
00101 \textcolor{stringliteral}{    Notes}
00102 \textcolor{stringliteral}{    -----}
00103 \textcolor{stringliteral}{    Do not lose the type info if the sequence contains unknown objects.}
00104 \textcolor{stringliteral}{}
00105 \textcolor{stringliteral}{    """}
00106     \textcolor{keywordflow}{if} len(seq) == 0 :
00107         \textcolor{keywordflow}{return} seq
00108     \textcolor{keywordflow}{else} :
00109         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(len(seq) - 1, -1, -1) :
00110             \textcolor{keywordflow}{if} seq[i] != 0 :
00111                 \textcolor{keywordflow}{break}
00112         \textcolor{keywordflow}{return} seq[:i+1]
00113 
00114 
\hypertarget{polyutils_8py_source_l00115}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{00115} \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}(alist, trim=True) :
00116     \textcolor{stringliteral}{"""}
00117 \textcolor{stringliteral}{    Return argument as a list of 1-d arrays.}
00118 \textcolor{stringliteral}{}
00119 \textcolor{stringliteral}{    The returned list contains array(s) of dtype double, complex double, or}
00120 \textcolor{stringliteral}{    object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of}
00121 \textcolor{stringliteral}{    size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays}
00122 \textcolor{stringliteral}{    of size ``N`` (i.e., is "parsed by row"); and a higher dimensional array}
00123 \textcolor{stringliteral}{    raises a Value Error if it is not first reshaped into either a 1-d or 2-d}
00124 \textcolor{stringliteral}{    array.}
00125 \textcolor{stringliteral}{}
00126 \textcolor{stringliteral}{    Parameters}
00127 \textcolor{stringliteral}{    ----------}
00128 \textcolor{stringliteral}{    a : array\_like}
00129 \textcolor{stringliteral}{        A 1- or 2-d array\_like}
00130 \textcolor{stringliteral}{    trim : boolean, optional}
00131 \textcolor{stringliteral}{        When True, trailing zeros are removed from the inputs.}
00132 \textcolor{stringliteral}{        When False, the inputs are passed through intact.}
00133 \textcolor{stringliteral}{}
00134 \textcolor{stringliteral}{    Returns}
00135 \textcolor{stringliteral}{    -------}
00136 \textcolor{stringliteral}{    [a1, a2,...] : list of 1d-arrays}
00137 \textcolor{stringliteral}{        A copy of the input data as a list of 1-d arrays.}
00138 \textcolor{stringliteral}{}
00139 \textcolor{stringliteral}{    Raises}
00140 \textcolor{stringliteral}{    ------}
00141 \textcolor{stringliteral}{    ValueError :}
00142 \textcolor{stringliteral}{        Raised when `as\_series` cannot convert its input to 1-d arrays, or at}
00143 \textcolor{stringliteral}{        least one of the resulting arrays is empty.}
00144 \textcolor{stringliteral}{}
00145 \textcolor{stringliteral}{    Examples}
00146 \textcolor{stringliteral}{    --------}
00147 \textcolor{stringliteral}{    >>> from numpy import polynomial as P}
00148 \textcolor{stringliteral}{    >>> a = np.arange(4)}
00149 \textcolor{stringliteral}{    >>> P.as\_series(a)}
00150 \textcolor{stringliteral}{    [array([ 0.]), array([ 1.]), array([ 2.]), array([ 3.])]}
00151 \textcolor{stringliteral}{    >>> b = np.arange(6).reshape((2,3))}
00152 \textcolor{stringliteral}{    >>> P.as\_series(b)}
00153 \textcolor{stringliteral}{    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.])]}
00154 \textcolor{stringliteral}{}
00155 \textcolor{stringliteral}{    """}
00156     arrays = [np.array(a, ndmin=1, copy=0) \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} alist]
00157     \textcolor{keywordflow}{if} min([a.size \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays]) == 0 :
00158         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"Coefficient array is empty"})
00159     \textcolor{keywordflow}{if} \hyperlink{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}{any}([a.ndim != 1 \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays]) :
00160         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"Coefficient array is not 1-d"})
00161     \textcolor{keywordflow}{if} trim :
00162         arrays = [\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{trimseq}(a) \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays]
00163 
00164     \textcolor{keywordflow}{if} \hyperlink{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}{any}([a.dtype == np.dtype(object) \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays]) :
00165         ret = []
00166         \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays :
00167             \textcolor{keywordflow}{if} a.dtype != np.dtype(object) :
00168                 tmp = np.empty(len(a), dtype=np.dtype(object))
00169                 tmp[:] = a[:]
00170                 ret.append(tmp)
00171             \textcolor{keywordflow}{else} :
00172                 ret.append(a.copy())
00173     \textcolor{keywordflow}{else} :
00174         \textcolor{keywordflow}{try} :
00175             dtype = np.common\_type(*arrays)
00176         \textcolor{keywordflow}{except} :
00177             \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"Coefficient arrays have no common type"})
00178         ret = [np.array(a, copy=1, dtype=dtype) \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays]
00179     \textcolor{keywordflow}{return} ret
00180 
00181 
\hypertarget{polyutils_8py_source_l00182}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a505e3038cfd08b7f444ecca2234daa46}{00182} \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a505e3038cfd08b7f444ecca2234daa46}{trimcoef}(c, tol=0) :
00183     \textcolor{stringliteral}{"""}
00184 \textcolor{stringliteral}{    Remove "small" "trailing" coefficients from a polynomial.}
00185 \textcolor{stringliteral}{}
00186 \textcolor{stringliteral}{    "Small" means "small in absolute value" and is controlled by the}
00187 \textcolor{stringliteral}{    parameter `tol`; "trailing" means highest order coefficient(s), e.g., in}
00188 \textcolor{stringliteral}{    ``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)}
00189 \textcolor{stringliteral}{    both the 3-rd and 4-th order coefficients would be "trimmed."}
00190 \textcolor{stringliteral}{}
00191 \textcolor{stringliteral}{    Parameters}
00192 \textcolor{stringliteral}{    ----------}
00193 \textcolor{stringliteral}{    c : array\_like}
00194 \textcolor{stringliteral}{        1-d array of coefficients, ordered from lowest order to highest.}
00195 \textcolor{stringliteral}{    tol : number, optional}
00196 \textcolor{stringliteral}{        Trailing (i.e., highest order) elements with absolute value less}
00197 \textcolor{stringliteral}{        than or equal to `tol` (default value is zero) are removed.}
00198 \textcolor{stringliteral}{}
00199 \textcolor{stringliteral}{    Returns}
00200 \textcolor{stringliteral}{    -------}
00201 \textcolor{stringliteral}{    trimmed : ndarray}
00202 \textcolor{stringliteral}{        1-d array with trailing zeros removed.  If the resulting series}
00203 \textcolor{stringliteral}{        would be empty, a series containing a single zero is returned.}
00204 \textcolor{stringliteral}{}
00205 \textcolor{stringliteral}{    Raises}
00206 \textcolor{stringliteral}{    ------}
00207 \textcolor{stringliteral}{    ValueError}
00208 \textcolor{stringliteral}{        If `tol` < 0}
00209 \textcolor{stringliteral}{}
00210 \textcolor{stringliteral}{    See Also}
00211 \textcolor{stringliteral}{    --------}
00212 \textcolor{stringliteral}{    trimseq}
00213 \textcolor{stringliteral}{}
00214 \textcolor{stringliteral}{    Examples}
00215 \textcolor{stringliteral}{    --------}
00216 \textcolor{stringliteral}{    >>> from numpy import polynomial as P}
00217 \textcolor{stringliteral}{    >>> P.trimcoef((0,0,3,0,5,0,0))}
00218 \textcolor{stringliteral}{    array([ 0.,  0.,  3.,  0.,  5.])}
00219 \textcolor{stringliteral}{    >>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed}
00220 \textcolor{stringliteral}{    array([ 0.])}
00221 \textcolor{stringliteral}{    >>> i = complex(0,1) # works for complex}
00222 \textcolor{stringliteral}{    >>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)}
00223 \textcolor{stringliteral}{    array([ 0.0003+0.j   ,  0.0010-0.001j])}
00224 \textcolor{stringliteral}{}
00225 \textcolor{stringliteral}{    """}
00226     \textcolor{keywordflow}{if} tol < 0 :
00227         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"tol must be non-negative"})
00228 
00229     [c] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([c])
00230     [ind] = np.where(np.abs(c) > tol)
00231     \textcolor{keywordflow}{if} len(ind) == 0 :
00232         \textcolor{keywordflow}{return} c[:1]*0
00233     \textcolor{keywordflow}{else} :
00234         \textcolor{keywordflow}{return} c[:ind[-1] + 1].copy()
00235 
\hypertarget{polyutils_8py_source_l00236}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_afbf8321a135ca2dc247215e16ea3399f}{00236} \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_afbf8321a135ca2dc247215e16ea3399f}{getdomain}(x) :
00237     \textcolor{stringliteral}{"""}
00238 \textcolor{stringliteral}{    Return a domain suitable for given abscissae.}
00239 \textcolor{stringliteral}{}
00240 \textcolor{stringliteral}{    Find a domain suitable for a polynomial or Chebyshev series}
00241 \textcolor{stringliteral}{    defined at the values supplied.}
00242 \textcolor{stringliteral}{}
00243 \textcolor{stringliteral}{    Parameters}
00244 \textcolor{stringliteral}{    ----------}
00245 \textcolor{stringliteral}{    x : array\_like}
00246 \textcolor{stringliteral}{        1-d array of abscissae whose domain will be determined.}
00247 \textcolor{stringliteral}{}
00248 \textcolor{stringliteral}{    Returns}
00249 \textcolor{stringliteral}{    -------}
00250 \textcolor{stringliteral}{    domain : ndarray}
00251 \textcolor{stringliteral}{        1-d array containing two values.  If the inputs are complex, then}
00252 \textcolor{stringliteral}{        the two returned points are the lower left and upper right corners}
00253 \textcolor{stringliteral}{        of the smallest rectangle (aligned with the axes) in the complex}
00254 \textcolor{stringliteral}{        plane containing the points `x`. If the inputs are real, then the}
00255 \textcolor{stringliteral}{        two points are the ends of the smallest interval containing the}
00256 \textcolor{stringliteral}{        points `x`.}
00257 \textcolor{stringliteral}{}
00258 \textcolor{stringliteral}{    See Also}
00259 \textcolor{stringliteral}{    --------}
00260 \textcolor{stringliteral}{    mapparms, mapdomain}
00261 \textcolor{stringliteral}{}
00262 \textcolor{stringliteral}{    Examples}
00263 \textcolor{stringliteral}{    --------}
00264 \textcolor{stringliteral}{    >>> from numpy.polynomial import polyutils as pu}
00265 \textcolor{stringliteral}{    >>> points = np.arange(4)**2 - 5; points}
00266 \textcolor{stringliteral}{    array([-5, -4, -1,  4])}
00267 \textcolor{stringliteral}{    >>> pu.getdomain(points)}
00268 \textcolor{stringliteral}{    array([-5.,  4.])}
00269 \textcolor{stringliteral}{    >>> c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle}
00270 \textcolor{stringliteral}{    >>> pu.getdomain(c)}
00271 \textcolor{stringliteral}{    array([-1.-1.j,  1.+1.j])}
00272 \textcolor{stringliteral}{}
00273 \textcolor{stringliteral}{    """}
00274     [x] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([x], trim=\textcolor{keyword}{False})
00275     \textcolor{keywordflow}{if} x.dtype.char \textcolor{keywordflow}{in} np.typecodes[\textcolor{stringliteral}{'Complex'}] :
00276         rmin, rmax = x.real.min(), x.real.max()
00277         imin, imax = x.imag.min(), x.imag.max()
00278         \textcolor{keywordflow}{return} np.array((complex(rmin, imin), complex(rmax, imax)))
00279     \textcolor{keywordflow}{else} :
00280         \textcolor{keywordflow}{return} np.array((x.min(), x.max()))
00281 
\hypertarget{polyutils_8py_source_l00282}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a6d5e6ebb1be7c9077ec3ae28e803c83c}{00282} \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a6d5e6ebb1be7c9077ec3ae28e803c83c}{mapparms}(old, new) :
00283     \textcolor{stringliteral}{"""}
00284 \textcolor{stringliteral}{    Linear map parameters between domains.}
00285 \textcolor{stringliteral}{}
00286 \textcolor{stringliteral}{    Return the parameters of the linear map ``offset + scale*x`` that maps}
00287 \textcolor{stringliteral}{    `old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.}
00288 \textcolor{stringliteral}{}
00289 \textcolor{stringliteral}{    Parameters}
00290 \textcolor{stringliteral}{    ----------}
00291 \textcolor{stringliteral}{    old, new : array\_like}
00292 \textcolor{stringliteral}{        Domains. Each domain must (successfully) convert to a 1-d array}
00293 \textcolor{stringliteral}{        containing precisely two values.}
00294 \textcolor{stringliteral}{}
00295 \textcolor{stringliteral}{    Returns}
00296 \textcolor{stringliteral}{    -------}
00297 \textcolor{stringliteral}{    offset, scale : scalars}
00298 \textcolor{stringliteral}{        The map ``L(x) = offset + scale*x`` maps the first domain to the}
00299 \textcolor{stringliteral}{        second.}
00300 \textcolor{stringliteral}{}
00301 \textcolor{stringliteral}{    See Also}
00302 \textcolor{stringliteral}{    --------}
00303 \textcolor{stringliteral}{    getdomain, mapdomain}
00304 \textcolor{stringliteral}{}
00305 \textcolor{stringliteral}{    Notes}
00306 \textcolor{stringliteral}{    -----}
00307 \textcolor{stringliteral}{    Also works for complex numbers, and thus can be used to calculate the}
00308 \textcolor{stringliteral}{    parameters required to map any line in the complex plane to any other}
00309 \textcolor{stringliteral}{    line therein.}
00310 \textcolor{stringliteral}{}
00311 \textcolor{stringliteral}{    Examples}
00312 \textcolor{stringliteral}{    --------}
00313 \textcolor{stringliteral}{    >>> from numpy import polynomial as P}
00314 \textcolor{stringliteral}{    >>> P.mapparms((-1,1),(-1,1))}
00315 \textcolor{stringliteral}{    (0.0, 1.0)}
00316 \textcolor{stringliteral}{    >>> P.mapparms((1,-1),(-1,1))}
00317 \textcolor{stringliteral}{    (0.0, -1.0)}
00318 \textcolor{stringliteral}{    >>> i = complex(0,1)}
00319 \textcolor{stringliteral}{    >>> P.mapparms((-i,-1),(1,i))}
00320 \textcolor{stringliteral}{    ((1+1j), (1+0j))}
00321 \textcolor{stringliteral}{}
00322 \textcolor{stringliteral}{    """}
00323     oldlen = old[1] - old[0]
00324     newlen = new[1] - new[0]
00325     off = (old[1]*new[0] - old[0]*new[1])/oldlen
00326     scl = newlen/oldlen
00327     \textcolor{keywordflow}{return} off, scl
00328 
\hypertarget{polyutils_8py_source_l00329}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_ad7fe440bbe8d96e839de461f4db98cef}{00329} \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_ad7fe440bbe8d96e839de461f4db98cef}{mapdomain}(x, old, new) :
00330     \textcolor{stringliteral}{"""}
00331 \textcolor{stringliteral}{    Apply linear map to input points.}
00332 \textcolor{stringliteral}{}
00333 \textcolor{stringliteral}{    The linear map ``offset + scale*x`` that maps the domain `old` to}
00334 \textcolor{stringliteral}{    the domain `new` is applied to the points `x`.}
00335 \textcolor{stringliteral}{}
00336 \textcolor{stringliteral}{    Parameters}
00337 \textcolor{stringliteral}{    ----------}
00338 \textcolor{stringliteral}{    x : array\_like}
00339 \textcolor{stringliteral}{        Points to be mapped. If `x` is a subtype of ndarray the subtype}
00340 \textcolor{stringliteral}{        will be preserved.}
00341 \textcolor{stringliteral}{    old, new : array\_like}
00342 \textcolor{stringliteral}{        The two domains that determine the map.  Each must (successfully)}
00343 \textcolor{stringliteral}{        convert to 1-d arrays containing precisely two values.}
00344 \textcolor{stringliteral}{}
00345 \textcolor{stringliteral}{    Returns}
00346 \textcolor{stringliteral}{    -------}
00347 \textcolor{stringliteral}{    x\_out : ndarray}
00348 \textcolor{stringliteral}{        Array of points of the same shape as `x`, after application of the}
00349 \textcolor{stringliteral}{        linear map between the two domains.}
00350 \textcolor{stringliteral}{}
00351 \textcolor{stringliteral}{    See Also}
00352 \textcolor{stringliteral}{    --------}
00353 \textcolor{stringliteral}{    getdomain, mapparms}
00354 \textcolor{stringliteral}{}
00355 \textcolor{stringliteral}{    Notes}
00356 \textcolor{stringliteral}{    -----}
00357 \textcolor{stringliteral}{    Effectively, this implements:}
00358 \textcolor{stringliteral}{}
00359 \textcolor{stringliteral}{    .. math ::}
00360 \textcolor{stringliteral}{        x\(\backslash\)\(\backslash\)\_out = new[0] + m(x - old[0])}
00361 \textcolor{stringliteral}{}
00362 \textcolor{stringliteral}{    where}
00363 \textcolor{stringliteral}{}
00364 \textcolor{stringliteral}{    .. math ::}
00365 \textcolor{stringliteral}{        m = \(\backslash\)\(\backslash\)frac\{new[1]-new[0]\}\{old[1]-old[0]\}}
00366 \textcolor{stringliteral}{}
00367 \textcolor{stringliteral}{    Examples}
00368 \textcolor{stringliteral}{    --------}
00369 \textcolor{stringliteral}{    >>> from numpy import polynomial as P}
00370 \textcolor{stringliteral}{    >>> old\_domain = (-1,1)}
00371 \textcolor{stringliteral}{    >>> new\_domain = (0,2*np.pi)}
00372 \textcolor{stringliteral}{    >>> x = np.linspace(-1,1,6); x}
00373 \textcolor{stringliteral}{    array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])}
00374 \textcolor{stringliteral}{    >>> x\_out = P.mapdomain(x, old\_domain, new\_domain); x\_out}
00375 \textcolor{stringliteral}{    array([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825,}
00376 \textcolor{stringliteral}{            6.28318531])}
00377 \textcolor{stringliteral}{    >>> x - P.mapdomain(x\_out, new\_domain, old\_domain)}
00378 \textcolor{stringliteral}{    array([ 0.,  0.,  0.,  0.,  0.,  0.])}
00379 \textcolor{stringliteral}{}
00380 \textcolor{stringliteral}{    Also works for complex numbers (and thus can be used to map any line in}
00381 \textcolor{stringliteral}{    the complex plane to any other line therein).}
00382 \textcolor{stringliteral}{}
00383 \textcolor{stringliteral}{    >>> i = complex(0,1)}
00384 \textcolor{stringliteral}{    >>> old = (-1 - i, 1 + i)}
00385 \textcolor{stringliteral}{    >>> new = (-1 + i, 1 - i)}
00386 \textcolor{stringliteral}{    >>> z = np.linspace(old[0], old[1], 6); z}
00387 \textcolor{stringliteral}{    array([-1.0-1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1.0+1.j ])}
00388 \textcolor{stringliteral}{    >>> new\_z = P.mapdomain(z, old, new); new\_z}
00389 \textcolor{stringliteral}{    array([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ])}
00390 \textcolor{stringliteral}{}
00391 \textcolor{stringliteral}{    """}
00392     x = np.asanyarray(x)
00393     off, scl = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a6d5e6ebb1be7c9077ec3ae28e803c83c}{mapparms}(old, new)
00394     \textcolor{keywordflow}{return} off + scl*x
\end{DoxyCode}
