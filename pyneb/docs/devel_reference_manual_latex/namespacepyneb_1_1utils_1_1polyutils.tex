\hypertarget{namespacepyneb_1_1utils_1_1polyutils}{\section{pyneb.\-utils.\-polyutils Namespace Reference}
\label{namespacepyneb_1_1utils_1_1polyutils}\index{pyneb.\-utils.\-polyutils@{pyneb.\-utils.\-polyutils}}
}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_rank_warning}{Rank\-Warning}
\item 
class \hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_poly_error}{Poly\-Error}
\item 
class \hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_poly_domain_error}{Poly\-Domain\-Error}
\item 
class \hyperlink{classpyneb_1_1utils_1_1polyutils_1_1_poly_base}{Poly\-Base}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}{any}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{trimseq}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\-\_\-series}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a505e3038cfd08b7f444ecca2234daa46}{trimcoef}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1polyutils_afbf8321a135ca2dc247215e16ea3399f}{getdomain}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a6d5e6ebb1be7c9077ec3ae28e803c83c}{mapparms}
\item 
def \hyperlink{namespacepyneb_1_1utils_1_1polyutils_ad7fe440bbe8d96e839de461f4db98cef}{mapdomain}
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a5e54a45bb5c6fa4444f663a0b0da0e1f}{\-\_\-\-\_\-all\-\_\-\-\_\-}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Utililty objects for the polynomial modules.

This module provides: error and warning objects; a polynomial base class;
and some routines used in both the `polynomial` and `chebyshev` modules.

Error objects
-------------
- `PolyError` -- base class for this sub-package's errors.
- `PolyDomainError` -- raised when domains are "mismatched."

Warning objects
---------------
- `RankWarning` -- raised by a least-squares fit when a rank-deficient
  matrix is encountered.

Base class
----------
- `PolyBase` -- The base class for the `Polynomial` and `Chebyshev`
  classes.

Functions
---------
- `as_series` -- turns a list of array_likes into 1-D arrays of common
  type.
- `trimseq` -- removes trailing zeros.
- `trimcoef` -- removes trailing coefficients that are less than a given
  magnitude (thereby removing the corresponding terms).
- `getdomain` -- returns a domain appropriate for a given set of abscissae.
- `mapdomain` -- maps points between domains.
- `mapparms` -- parameters of the linear map between domains.\end{DoxyVerb}
 

\subsection{Function Documentation}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}{\index{pyneb\-::utils\-::polyutils@{pyneb\-::utils\-::polyutils}!any@{any}}
\index{any@{any}!pyneb::utils::polyutils@{pyneb\-::utils\-::polyutils}}
\subsubsection[{any}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-polyutils.\-any (
\begin{DoxyParamCaption}
\item[{}]{iterable}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}


Definition at line \hyperlink{polyutils_8py_source_l00076}{76} of file \hyperlink{polyutils_8py_source}{polyutils.\-py}.



Referenced by \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_l00076}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}{00076} 
00077     \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}{any}(iterable) :
00078         \textcolor{keywordflow}{for} element \textcolor{keywordflow}{in} iterable:
00079             \textcolor{keywordflow}{if} element :
00080                 \textcolor{keywordflow}{return} \textcolor{keyword}{True}
00081         \textcolor{keywordflow}{return} \textcolor{keyword}{False}
00082 
00083 \textcolor{comment}{#}
00084 \textcolor{comment}{# Helper functions to convert inputs to 1d arrays}
\textcolor{comment}{#}
\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{\index{pyneb\-::utils\-::polyutils@{pyneb\-::utils\-::polyutils}!as\-\_\-series@{as\-\_\-series}}
\index{as\-\_\-series@{as\-\_\-series}!pyneb::utils::polyutils@{pyneb\-::utils\-::polyutils}}
\subsubsection[{as\-\_\-series}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-polyutils.\-as\-\_\-series (
\begin{DoxyParamCaption}
\item[{}]{alist, }
\item[{}]{trim = {\ttfamily True}}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}
\begin{DoxyVerb}Return argument as a list of 1-d arrays.

The returned list contains array(s) of dtype double, complex double, or
object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of
size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays
of size ``N`` (i.e., is "parsed by row"); and a higher dimensional array
raises a Value Error if it is not first reshaped into either a 1-d or 2-d
array.

Parameters
----------
a : array_like
    A 1- or 2-d array_like
trim : boolean, optional
    When True, trailing zeros are removed from the inputs.
    When False, the inputs are passed through intact.

Returns
-------
[a1, a2,...] : list of 1d-arrays
    A copy of the input data as a list of 1-d arrays.

Raises
------
ValueError :
    Raised when `as_series` cannot convert its input to 1-d arrays, or at
    least one of the resulting arrays is empty.

Examples
--------
>>> from numpy import polynomial as P
>>> a = np.arange(4)
>>> P.as_series(a)
[array([ 0.]), array([ 1.]), array([ 2.]), array([ 3.])]
>>> b = np.arange(6).reshape((2,3))
>>> P.as_series(b)
[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.])]\end{DoxyVerb}
 

Definition at line \hyperlink{polyutils_8py_source_l00115}{115} of file \hyperlink{polyutils_8py_source}{polyutils.\-py}.



References \hyperlink{polyutils_8py_source_l00076}{pyneb.\-utils.\-polyutils.\-any()}, and \hyperlink{polyutils_8py_source_l00085}{pyneb.\-utils.\-polyutils.\-trimseq()}.



Referenced by \hyperlink{chebyshev_8py_source_l00359}{pyneb.\-utils.\-chebyshev.\-cheb2poly()}, \hyperlink{chebyshev_8py_source_l00534}{pyneb.\-utils.\-chebyshev.\-chebadd()}, \hyperlink{chebyshev_8py_source_l00841}{pyneb.\-utils.\-chebyshev.\-chebder()}, \hyperlink{chebyshev_8py_source_l00725}{pyneb.\-utils.\-chebyshev.\-chebdiv()}, \hyperlink{chebyshev_8py_source_l00472}{pyneb.\-utils.\-chebyshev.\-chebfromroots()}, \hyperlink{chebyshev_8py_source_l00912}{pyneb.\-utils.\-chebyshev.\-chebint()}, \hyperlink{chebyshev_8py_source_l00676}{pyneb.\-utils.\-chebyshev.\-chebmul()}, \hyperlink{chebyshev_8py_source_l00637}{pyneb.\-utils.\-chebyshev.\-chebmulx()}, \hyperlink{chebyshev_8py_source_l00790}{pyneb.\-utils.\-chebyshev.\-chebpow()}, \hyperlink{chebyshev_8py_source_l01276}{pyneb.\-utils.\-chebyshev.\-chebroots()}, \hyperlink{chebyshev_8py_source_l00584}{pyneb.\-utils.\-chebyshev.\-chebsub()}, \hyperlink{chebyshev_8py_source_l01018}{pyneb.\-utils.\-chebyshev.\-chebval()}, \hyperlink{polyutils_8py_source_l00236}{pyneb.\-utils.\-polyutils.\-getdomain()}, \hyperlink{chebyshev_8py_source_l00309}{pyneb.\-utils.\-chebyshev.\-poly2cheb()}, and \hyperlink{polyutils_8py_source_l00182}{pyneb.\-utils.\-polyutils.\-trimcoef()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_l00115}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{00115} 
00116 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}(alist, trim=True) :
00117     \textcolor{stringliteral}{"""}
00118 \textcolor{stringliteral}{    Return argument as a list of 1-d arrays.}
00119 \textcolor{stringliteral}{}
00120 \textcolor{stringliteral}{    The returned list contains array(s) of dtype double, complex double, or}
00121 \textcolor{stringliteral}{    object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of}
00122 \textcolor{stringliteral}{    size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays}
00123 \textcolor{stringliteral}{    of size ``N`` (i.e., is "parsed by row"); and a higher dimensional array}
00124 \textcolor{stringliteral}{    raises a Value Error if it is not first reshaped into either a 1-d or 2-d}
00125 \textcolor{stringliteral}{    array.}
00126 \textcolor{stringliteral}{}
00127 \textcolor{stringliteral}{    Parameters}
00128 \textcolor{stringliteral}{    ----------}
00129 \textcolor{stringliteral}{    a : array\_like}
00130 \textcolor{stringliteral}{        A 1- or 2-d array\_like}
00131 \textcolor{stringliteral}{    trim : boolean, optional}
00132 \textcolor{stringliteral}{        When True, trailing zeros are removed from the inputs.}
00133 \textcolor{stringliteral}{        When False, the inputs are passed through intact.}
00134 \textcolor{stringliteral}{}
00135 \textcolor{stringliteral}{    Returns}
00136 \textcolor{stringliteral}{    -------}
00137 \textcolor{stringliteral}{    [a1, a2,...] : list of 1d-arrays}
00138 \textcolor{stringliteral}{        A copy of the input data as a list of 1-d arrays.}
00139 \textcolor{stringliteral}{}
00140 \textcolor{stringliteral}{    Raises}
00141 \textcolor{stringliteral}{    ------}
00142 \textcolor{stringliteral}{    ValueError :}
00143 \textcolor{stringliteral}{        Raised when `as\_series` cannot convert its input to 1-d arrays, or at}
00144 \textcolor{stringliteral}{        least one of the resulting arrays is empty.}
00145 \textcolor{stringliteral}{}
00146 \textcolor{stringliteral}{    Examples}
00147 \textcolor{stringliteral}{    --------}
00148 \textcolor{stringliteral}{    >>> from numpy import polynomial as P}
00149 \textcolor{stringliteral}{    >>> a = np.arange(4)}
00150 \textcolor{stringliteral}{    >>> P.as\_series(a)}
00151 \textcolor{stringliteral}{    [array([ 0.]), array([ 1.]), array([ 2.]), array([ 3.])]}
00152 \textcolor{stringliteral}{    >>> b = np.arange(6).reshape((2,3))}
00153 \textcolor{stringliteral}{    >>> P.as\_series(b)}
00154 \textcolor{stringliteral}{    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.])]}
00155 \textcolor{stringliteral}{}
00156 \textcolor{stringliteral}{    """}
00157     arrays = [np.array(a, ndmin=1, copy=0) \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} alist]
00158     \textcolor{keywordflow}{if} min([a.size \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays]) == 0 :
00159         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"Coefficient array is empty"})
00160     \textcolor{keywordflow}{if} \hyperlink{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}{any}([a.ndim != 1 \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays]) :
00161         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"Coefficient array is not 1-d"})
00162     \textcolor{keywordflow}{if} trim :
00163         arrays = [\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{trimseq}(a) \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays]
00164 
00165     \textcolor{keywordflow}{if} \hyperlink{namespacepyneb_1_1utils_1_1polyutils_ae57e4cc7030d5459a7e7c1f61d7ed9a8}{any}([a.dtype == np.dtype(object) \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays]) :
00166         ret = []
00167         \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays :
00168             \textcolor{keywordflow}{if} a.dtype != np.dtype(object) :
00169                 tmp = np.empty(len(a), dtype=np.dtype(object))
00170                 tmp[:] = a[:]
00171                 ret.append(tmp)
00172             \textcolor{keywordflow}{else} :
00173                 ret.append(a.copy())
00174     \textcolor{keywordflow}{else} :
00175         \textcolor{keywordflow}{try} :
00176             dtype = np.common\_type(*arrays)
00177         \textcolor{keywordflow}{except} :
00178             \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"Coefficient arrays have no common type"})
00179         ret = [np.array(a, copy=1, dtype=dtype) \textcolor{keywordflow}{for} a \textcolor{keywordflow}{in} arrays]
00180     \textcolor{keywordflow}{return} ret
00181 

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_afbf8321a135ca2dc247215e16ea3399f}{\index{pyneb\-::utils\-::polyutils@{pyneb\-::utils\-::polyutils}!getdomain@{getdomain}}
\index{getdomain@{getdomain}!pyneb::utils::polyutils@{pyneb\-::utils\-::polyutils}}
\subsubsection[{getdomain}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-polyutils.\-getdomain (
\begin{DoxyParamCaption}
\item[{}]{x}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1polyutils_afbf8321a135ca2dc247215e16ea3399f}
\begin{DoxyVerb}Return a domain suitable for given abscissae.

Find a domain suitable for a polynomial or Chebyshev series
defined at the values supplied.

Parameters
----------
x : array_like
    1-d array of abscissae whose domain will be determined.

Returns
-------
domain : ndarray
    1-d array containing two values.  If the inputs are complex, then
    the two returned points are the lower left and upper right corners
    of the smallest rectangle (aligned with the axes) in the complex
    plane containing the points `x`. If the inputs are real, then the
    two points are the ends of the smallest interval containing the
    points `x`.

See Also
--------
mapparms, mapdomain

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> points = np.arange(4)**2 - 5; points
array([-5, -4, -1,  4])
>>> pu.getdomain(points)
array([-5.,  4.])
>>> c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle
>>> pu.getdomain(c)
array([-1.-1.j,  1.+1.j])\end{DoxyVerb}
 

Definition at line \hyperlink{polyutils_8py_source_l00236}{236} of file \hyperlink{polyutils_8py_source}{polyutils.\-py}.



References \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_l00236}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_afbf8321a135ca2dc247215e16ea3399f}{00236} 
00237 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_afbf8321a135ca2dc247215e16ea3399f}{getdomain}(x) :
00238     \textcolor{stringliteral}{"""}
00239 \textcolor{stringliteral}{    Return a domain suitable for given abscissae.}
00240 \textcolor{stringliteral}{}
00241 \textcolor{stringliteral}{    Find a domain suitable for a polynomial or Chebyshev series}
00242 \textcolor{stringliteral}{    defined at the values supplied.}
00243 \textcolor{stringliteral}{}
00244 \textcolor{stringliteral}{    Parameters}
00245 \textcolor{stringliteral}{    ----------}
00246 \textcolor{stringliteral}{    x : array\_like}
00247 \textcolor{stringliteral}{        1-d array of abscissae whose domain will be determined.}
00248 \textcolor{stringliteral}{}
00249 \textcolor{stringliteral}{    Returns}
00250 \textcolor{stringliteral}{    -------}
00251 \textcolor{stringliteral}{    domain : ndarray}
00252 \textcolor{stringliteral}{        1-d array containing two values.  If the inputs are complex, then}
00253 \textcolor{stringliteral}{        the two returned points are the lower left and upper right corners}
00254 \textcolor{stringliteral}{        of the smallest rectangle (aligned with the axes) in the complex}
00255 \textcolor{stringliteral}{        plane containing the points `x`. If the inputs are real, then the}
00256 \textcolor{stringliteral}{        two points are the ends of the smallest interval containing the}
00257 \textcolor{stringliteral}{        points `x`.}
00258 \textcolor{stringliteral}{}
00259 \textcolor{stringliteral}{    See Also}
00260 \textcolor{stringliteral}{    --------}
00261 \textcolor{stringliteral}{    mapparms, mapdomain}
00262 \textcolor{stringliteral}{}
00263 \textcolor{stringliteral}{    Examples}
00264 \textcolor{stringliteral}{    --------}
00265 \textcolor{stringliteral}{    >>> from numpy.polynomial import polyutils as pu}
00266 \textcolor{stringliteral}{    >>> points = np.arange(4)**2 - 5; points}
00267 \textcolor{stringliteral}{    array([-5, -4, -1,  4])}
00268 \textcolor{stringliteral}{    >>> pu.getdomain(points)}
00269 \textcolor{stringliteral}{    array([-5.,  4.])}
00270 \textcolor{stringliteral}{    >>> c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle}
00271 \textcolor{stringliteral}{    >>> pu.getdomain(c)}
00272 \textcolor{stringliteral}{    array([-1.-1.j,  1.+1.j])}
00273 \textcolor{stringliteral}{}
00274 \textcolor{stringliteral}{    """}
00275     [x] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([x], trim=\textcolor{keyword}{False})
00276     \textcolor{keywordflow}{if} x.dtype.char \textcolor{keywordflow}{in} np.typecodes[\textcolor{stringliteral}{'Complex'}] :
00277         rmin, rmax = x.real.min(), x.real.max()
00278         imin, imax = x.imag.min(), x.imag.max()
00279         \textcolor{keywordflow}{return} np.array((complex(rmin, imin), complex(rmax, imax)))
00280     \textcolor{keywordflow}{else} :
00281         \textcolor{keywordflow}{return} np.array((x.min(), x.max()))

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_ad7fe440bbe8d96e839de461f4db98cef}{\index{pyneb\-::utils\-::polyutils@{pyneb\-::utils\-::polyutils}!mapdomain@{mapdomain}}
\index{mapdomain@{mapdomain}!pyneb::utils::polyutils@{pyneb\-::utils\-::polyutils}}
\subsubsection[{mapdomain}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-polyutils.\-mapdomain (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{old, }
\item[{}]{new}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1polyutils_ad7fe440bbe8d96e839de461f4db98cef}
\begin{DoxyVerb}Apply linear map to input points.

The linear map ``offset + scale*x`` that maps the domain `old` to
the domain `new` is applied to the points `x`.

Parameters
----------
x : array_like
    Points to be mapped. If `x` is a subtype of ndarray the subtype
    will be preserved.
old, new : array_like
    The two domains that determine the map.  Each must (successfully)
    convert to 1-d arrays containing precisely two values.

Returns
-------
x_out : ndarray
    Array of points of the same shape as `x`, after application of the
    linear map between the two domains.

See Also
--------
getdomain, mapparms

Notes
-----
Effectively, this implements:

.. math ::
    x\\_out = new[0] + m(x - old[0])

where

.. math ::
    m = \\frac{new[1]-new[0]}{old[1]-old[0]}

Examples
--------
>>> from numpy import polynomial as P
>>> old_domain = (-1,1)
>>> new_domain = (0,2*np.pi)
>>> x = np.linspace(-1,1,6); x
array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])
>>> x_out = P.mapdomain(x, old_domain, new_domain); x_out
array([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825,
        6.28318531])
>>> x - P.mapdomain(x_out, new_domain, old_domain)
array([ 0.,  0.,  0.,  0.,  0.,  0.])

Also works for complex numbers (and thus can be used to map any line in
the complex plane to any other line therein).

>>> i = complex(0,1)
>>> old = (-1 - i, 1 + i)
>>> new = (-1 + i, 1 - i)
>>> z = np.linspace(old[0], old[1], 6); z
array([-1.0-1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1.0+1.j ])
>>> new_z = P.mapdomain(z, old, new); new_z
array([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ])\end{DoxyVerb}
 

Definition at line \hyperlink{polyutils_8py_source_l00329}{329} of file \hyperlink{polyutils_8py_source}{polyutils.\-py}.



References \hyperlink{polyutils_8py_source_l00282}{pyneb.\-utils.\-polyutils.\-mapparms()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_l00329}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_ad7fe440bbe8d96e839de461f4db98cef}{00329} 
00330 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_ad7fe440bbe8d96e839de461f4db98cef}{mapdomain}(x, old, new) :
00331     \textcolor{stringliteral}{"""}
00332 \textcolor{stringliteral}{    Apply linear map to input points.}
00333 \textcolor{stringliteral}{}
00334 \textcolor{stringliteral}{    The linear map ``offset + scale*x`` that maps the domain `old` to}
00335 \textcolor{stringliteral}{    the domain `new` is applied to the points `x`.}
00336 \textcolor{stringliteral}{}
00337 \textcolor{stringliteral}{    Parameters}
00338 \textcolor{stringliteral}{    ----------}
00339 \textcolor{stringliteral}{    x : array\_like}
00340 \textcolor{stringliteral}{        Points to be mapped. If `x` is a subtype of ndarray the subtype}
00341 \textcolor{stringliteral}{        will be preserved.}
00342 \textcolor{stringliteral}{    old, new : array\_like}
00343 \textcolor{stringliteral}{        The two domains that determine the map.  Each must (successfully)}
00344 \textcolor{stringliteral}{        convert to 1-d arrays containing precisely two values.}
00345 \textcolor{stringliteral}{}
00346 \textcolor{stringliteral}{    Returns}
00347 \textcolor{stringliteral}{    -------}
00348 \textcolor{stringliteral}{    x\_out : ndarray}
00349 \textcolor{stringliteral}{        Array of points of the same shape as `x`, after application of the}
00350 \textcolor{stringliteral}{        linear map between the two domains.}
00351 \textcolor{stringliteral}{}
00352 \textcolor{stringliteral}{    See Also}
00353 \textcolor{stringliteral}{    --------}
00354 \textcolor{stringliteral}{    getdomain, mapparms}
00355 \textcolor{stringliteral}{}
00356 \textcolor{stringliteral}{    Notes}
00357 \textcolor{stringliteral}{    -----}
00358 \textcolor{stringliteral}{    Effectively, this implements:}
00359 \textcolor{stringliteral}{}
00360 \textcolor{stringliteral}{    .. math ::}
00361 \textcolor{stringliteral}{        x\(\backslash\)\(\backslash\)\_out = new[0] + m(x - old[0])}
00362 \textcolor{stringliteral}{}
00363 \textcolor{stringliteral}{    where}
00364 \textcolor{stringliteral}{}
00365 \textcolor{stringliteral}{    .. math ::}
00366 \textcolor{stringliteral}{        m = \(\backslash\)\(\backslash\)frac\{new[1]-new[0]\}\{old[1]-old[0]\}}
00367 \textcolor{stringliteral}{}
00368 \textcolor{stringliteral}{    Examples}
00369 \textcolor{stringliteral}{    --------}
00370 \textcolor{stringliteral}{    >>> from numpy import polynomial as P}
00371 \textcolor{stringliteral}{    >>> old\_domain = (-1,1)}
00372 \textcolor{stringliteral}{    >>> new\_domain = (0,2*np.pi)}
00373 \textcolor{stringliteral}{    >>> x = np.linspace(-1,1,6); x}
00374 \textcolor{stringliteral}{    array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])}
00375 \textcolor{stringliteral}{    >>> x\_out = P.mapdomain(x, old\_domain, new\_domain); x\_out}
00376 \textcolor{stringliteral}{    array([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825,}
00377 \textcolor{stringliteral}{            6.28318531])}
00378 \textcolor{stringliteral}{    >>> x - P.mapdomain(x\_out, new\_domain, old\_domain)}
00379 \textcolor{stringliteral}{    array([ 0.,  0.,  0.,  0.,  0.,  0.])}
00380 \textcolor{stringliteral}{}
00381 \textcolor{stringliteral}{    Also works for complex numbers (and thus can be used to map any line in}
00382 \textcolor{stringliteral}{    the complex plane to any other line therein).}
00383 \textcolor{stringliteral}{}
00384 \textcolor{stringliteral}{    >>> i = complex(0,1)}
00385 \textcolor{stringliteral}{    >>> old = (-1 - i, 1 + i)}
00386 \textcolor{stringliteral}{    >>> new = (-1 + i, 1 - i)}
00387 \textcolor{stringliteral}{    >>> z = np.linspace(old[0], old[1], 6); z}
00388 \textcolor{stringliteral}{    array([-1.0-1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1.0+1.j ])}
00389 \textcolor{stringliteral}{    >>> new\_z = P.mapdomain(z, old, new); new\_z}
00390 \textcolor{stringliteral}{    array([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ])}
00391 \textcolor{stringliteral}{}
00392 \textcolor{stringliteral}{    """}
00393     x = np.asanyarray(x)
00394     off, scl = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a6d5e6ebb1be7c9077ec3ae28e803c83c}{mapparms}(old, new)
00395     \textcolor{keywordflow}{return} off + scl*x
\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_a6d5e6ebb1be7c9077ec3ae28e803c83c}{\index{pyneb\-::utils\-::polyutils@{pyneb\-::utils\-::polyutils}!mapparms@{mapparms}}
\index{mapparms@{mapparms}!pyneb::utils::polyutils@{pyneb\-::utils\-::polyutils}}
\subsubsection[{mapparms}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-polyutils.\-mapparms (
\begin{DoxyParamCaption}
\item[{}]{old, }
\item[{}]{new}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1polyutils_a6d5e6ebb1be7c9077ec3ae28e803c83c}
\begin{DoxyVerb}Linear map parameters between domains.

Return the parameters of the linear map ``offset + scale*x`` that maps
`old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.

Parameters
----------
old, new : array_like
    Domains. Each domain must (successfully) convert to a 1-d array
    containing precisely two values.

Returns
-------
offset, scale : scalars
    The map ``L(x) = offset + scale*x`` maps the first domain to the
    second.

See Also
--------
getdomain, mapdomain

Notes
-----
Also works for complex numbers, and thus can be used to calculate the
parameters required to map any line in the complex plane to any other
line therein.

Examples
--------
>>> from numpy import polynomial as P
>>> P.mapparms((-1,1),(-1,1))
(0.0, 1.0)
>>> P.mapparms((1,-1),(-1,1))
(0.0, -1.0)
>>> i = complex(0,1)
>>> P.mapparms((-i,-1),(1,i))
((1+1j), (1+0j))\end{DoxyVerb}
 

Definition at line \hyperlink{polyutils_8py_source_l00282}{282} of file \hyperlink{polyutils_8py_source}{polyutils.\-py}.



Referenced by \hyperlink{polyutils_8py_source_l00329}{pyneb.\-utils.\-polyutils.\-mapdomain()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_l00282}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a6d5e6ebb1be7c9077ec3ae28e803c83c}{00282} 
00283 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a6d5e6ebb1be7c9077ec3ae28e803c83c}{mapparms}(old, new) :
00284     \textcolor{stringliteral}{"""}
00285 \textcolor{stringliteral}{    Linear map parameters between domains.}
00286 \textcolor{stringliteral}{}
00287 \textcolor{stringliteral}{    Return the parameters of the linear map ``offset + scale*x`` that maps}
00288 \textcolor{stringliteral}{    `old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.}
00289 \textcolor{stringliteral}{}
00290 \textcolor{stringliteral}{    Parameters}
00291 \textcolor{stringliteral}{    ----------}
00292 \textcolor{stringliteral}{    old, new : array\_like}
00293 \textcolor{stringliteral}{        Domains. Each domain must (successfully) convert to a 1-d array}
00294 \textcolor{stringliteral}{        containing precisely two values.}
00295 \textcolor{stringliteral}{}
00296 \textcolor{stringliteral}{    Returns}
00297 \textcolor{stringliteral}{    -------}
00298 \textcolor{stringliteral}{    offset, scale : scalars}
00299 \textcolor{stringliteral}{        The map ``L(x) = offset + scale*x`` maps the first domain to the}
00300 \textcolor{stringliteral}{        second.}
00301 \textcolor{stringliteral}{}
00302 \textcolor{stringliteral}{    See Also}
00303 \textcolor{stringliteral}{    --------}
00304 \textcolor{stringliteral}{    getdomain, mapdomain}
00305 \textcolor{stringliteral}{}
00306 \textcolor{stringliteral}{    Notes}
00307 \textcolor{stringliteral}{    -----}
00308 \textcolor{stringliteral}{    Also works for complex numbers, and thus can be used to calculate the}
00309 \textcolor{stringliteral}{    parameters required to map any line in the complex plane to any other}
00310 \textcolor{stringliteral}{    line therein.}
00311 \textcolor{stringliteral}{}
00312 \textcolor{stringliteral}{    Examples}
00313 \textcolor{stringliteral}{    --------}
00314 \textcolor{stringliteral}{    >>> from numpy import polynomial as P}
00315 \textcolor{stringliteral}{    >>> P.mapparms((-1,1),(-1,1))}
00316 \textcolor{stringliteral}{    (0.0, 1.0)}
00317 \textcolor{stringliteral}{    >>> P.mapparms((1,-1),(-1,1))}
00318 \textcolor{stringliteral}{    (0.0, -1.0)}
00319 \textcolor{stringliteral}{    >>> i = complex(0,1)}
00320 \textcolor{stringliteral}{    >>> P.mapparms((-i,-1),(1,i))}
00321 \textcolor{stringliteral}{    ((1+1j), (1+0j))}
00322 \textcolor{stringliteral}{}
00323 \textcolor{stringliteral}{    """}
00324     oldlen = old[1] - old[0]
00325     newlen = new[1] - new[0]
00326     off = (old[1]*new[0] - old[0]*new[1])/oldlen
00327     scl = newlen/oldlen
00328     \textcolor{keywordflow}{return} off, scl

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_a505e3038cfd08b7f444ecca2234daa46}{\index{pyneb\-::utils\-::polyutils@{pyneb\-::utils\-::polyutils}!trimcoef@{trimcoef}}
\index{trimcoef@{trimcoef}!pyneb::utils::polyutils@{pyneb\-::utils\-::polyutils}}
\subsubsection[{trimcoef}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-polyutils.\-trimcoef (
\begin{DoxyParamCaption}
\item[{}]{c, }
\item[{}]{tol = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1polyutils_a505e3038cfd08b7f444ecca2234daa46}
\begin{DoxyVerb}Remove "small" "trailing" coefficients from a polynomial.

"Small" means "small in absolute value" and is controlled by the
parameter `tol`; "trailing" means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be "trimmed."

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` < 0

See Also
--------
trimseq

Examples
--------
>>> from numpy import polynomial as P
>>> P.trimcoef((0,0,3,0,5,0,0))
array([ 0.,  0.,  3.,  0.,  5.])
>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([ 0.])
>>> i = complex(0,1) # works for complex
>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([ 0.0003+0.j   ,  0.0010-0.001j])\end{DoxyVerb}
 

Definition at line \hyperlink{polyutils_8py_source_l00182}{182} of file \hyperlink{polyutils_8py_source}{polyutils.\-py}.



References \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_l00182}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a505e3038cfd08b7f444ecca2234daa46}{00182} 
00183 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a505e3038cfd08b7f444ecca2234daa46}{trimcoef}(c, tol=0) :
00184     \textcolor{stringliteral}{"""}
00185 \textcolor{stringliteral}{    Remove "small" "trailing" coefficients from a polynomial.}
00186 \textcolor{stringliteral}{}
00187 \textcolor{stringliteral}{    "Small" means "small in absolute value" and is controlled by the}
00188 \textcolor{stringliteral}{    parameter `tol`; "trailing" means highest order coefficient(s), e.g., in}
00189 \textcolor{stringliteral}{    ``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)}
00190 \textcolor{stringliteral}{    both the 3-rd and 4-th order coefficients would be "trimmed."}
00191 \textcolor{stringliteral}{}
00192 \textcolor{stringliteral}{    Parameters}
00193 \textcolor{stringliteral}{    ----------}
00194 \textcolor{stringliteral}{    c : array\_like}
00195 \textcolor{stringliteral}{        1-d array of coefficients, ordered from lowest order to highest.}
00196 \textcolor{stringliteral}{    tol : number, optional}
00197 \textcolor{stringliteral}{        Trailing (i.e., highest order) elements with absolute value less}
00198 \textcolor{stringliteral}{        than or equal to `tol` (default value is zero) are removed.}
00199 \textcolor{stringliteral}{}
00200 \textcolor{stringliteral}{    Returns}
00201 \textcolor{stringliteral}{    -------}
00202 \textcolor{stringliteral}{    trimmed : ndarray}
00203 \textcolor{stringliteral}{        1-d array with trailing zeros removed.  If the resulting series}
00204 \textcolor{stringliteral}{        would be empty, a series containing a single zero is returned.}
00205 \textcolor{stringliteral}{}
00206 \textcolor{stringliteral}{    Raises}
00207 \textcolor{stringliteral}{    ------}
00208 \textcolor{stringliteral}{    ValueError}
00209 \textcolor{stringliteral}{        If `tol` < 0}
00210 \textcolor{stringliteral}{}
00211 \textcolor{stringliteral}{    See Also}
00212 \textcolor{stringliteral}{    --------}
00213 \textcolor{stringliteral}{    trimseq}
00214 \textcolor{stringliteral}{}
00215 \textcolor{stringliteral}{    Examples}
00216 \textcolor{stringliteral}{    --------}
00217 \textcolor{stringliteral}{    >>> from numpy import polynomial as P}
00218 \textcolor{stringliteral}{    >>> P.trimcoef((0,0,3,0,5,0,0))}
00219 \textcolor{stringliteral}{    array([ 0.,  0.,  3.,  0.,  5.])}
00220 \textcolor{stringliteral}{    >>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed}
00221 \textcolor{stringliteral}{    array([ 0.])}
00222 \textcolor{stringliteral}{    >>> i = complex(0,1) # works for complex}
00223 \textcolor{stringliteral}{    >>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)}
00224 \textcolor{stringliteral}{    array([ 0.0003+0.j   ,  0.0010-0.001j])}
00225 \textcolor{stringliteral}{}
00226 \textcolor{stringliteral}{    """}
00227     \textcolor{keywordflow}{if} tol < 0 :
00228         \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"tol must be non-negative"})
00229 
00230     [c] = \hyperlink{namespacepyneb_1_1utils_1_1polyutils_a9c3751d438f0f75922155c7823fe2699}{as\_series}([c])
00231     [ind] = np.where(np.abs(c) > tol)
00232     \textcolor{keywordflow}{if} len(ind) == 0 :
00233         \textcolor{keywordflow}{return} c[:1]*0
00234     \textcolor{keywordflow}{else} :
00235         \textcolor{keywordflow}{return} c[:ind[-1] + 1].copy()

\end{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{\index{pyneb\-::utils\-::polyutils@{pyneb\-::utils\-::polyutils}!trimseq@{trimseq}}
\index{trimseq@{trimseq}!pyneb::utils::polyutils@{pyneb\-::utils\-::polyutils}}
\subsubsection[{trimseq}]{\setlength{\rightskip}{0pt plus 5cm}def pyneb.\-utils.\-polyutils.\-trimseq (
\begin{DoxyParamCaption}
\item[{}]{seq}
\end{DoxyParamCaption}
)}}\label{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}
\begin{DoxyVerb}Remove small Poly series coefficients.

Parameters
----------
seq : sequence
    Sequence of Poly series coefficients. This routine fails for
    empty sequences.

Returns
-------
series : sequence
    Subsequence with trailing zeros removed. If the resulting sequence
    would be empty, return the first element. The returned sequence may
    or may not be a view.

Notes
-----
Do not lose the type info if the sequence contains unknown objects.\end{DoxyVerb}
 

Definition at line \hyperlink{polyutils_8py_source_l00085}{85} of file \hyperlink{polyutils_8py_source}{polyutils.\-py}.



Referenced by \hyperlink{polyutils_8py_source_l00115}{pyneb.\-utils.\-polyutils.\-as\-\_\-series()}, \hyperlink{chebyshev_8py_source_l00534}{pyneb.\-utils.\-chebyshev.\-chebadd()}, \hyperlink{chebyshev_8py_source_l00725}{pyneb.\-utils.\-chebyshev.\-chebdiv()}, \hyperlink{chebyshev_8py_source_l00676}{pyneb.\-utils.\-chebyshev.\-chebmul()}, and \hyperlink{chebyshev_8py_source_l00584}{pyneb.\-utils.\-chebyshev.\-chebsub()}.


\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_l00085}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{00085} 
00086 \textcolor{keyword}{def }\hyperlink{namespacepyneb_1_1utils_1_1polyutils_a973183162fdba436dae4946ec78c009b}{trimseq}(seq) :
00087     \textcolor{stringliteral}{"""Remove small Poly series coefficients.}
00088 \textcolor{stringliteral}{}
00089 \textcolor{stringliteral}{    Parameters}
00090 \textcolor{stringliteral}{    ----------}
00091 \textcolor{stringliteral}{    seq : sequence}
00092 \textcolor{stringliteral}{        Sequence of Poly series coefficients. This routine fails for}
00093 \textcolor{stringliteral}{        empty sequences.}
00094 \textcolor{stringliteral}{}
00095 \textcolor{stringliteral}{    Returns}
00096 \textcolor{stringliteral}{    -------}
00097 \textcolor{stringliteral}{    series : sequence}
00098 \textcolor{stringliteral}{        Subsequence with trailing zeros removed. If the resulting sequence}
00099 \textcolor{stringliteral}{        would be empty, return the first element. The returned sequence may}
00100 \textcolor{stringliteral}{        or may not be a view.}
00101 \textcolor{stringliteral}{}
00102 \textcolor{stringliteral}{    Notes}
00103 \textcolor{stringliteral}{    -----}
00104 \textcolor{stringliteral}{    Do not lose the type info if the sequence contains unknown objects.}
00105 \textcolor{stringliteral}{}
00106 \textcolor{stringliteral}{    """}
00107     \textcolor{keywordflow}{if} len(seq) == 0 :
00108         \textcolor{keywordflow}{return} seq
00109     \textcolor{keywordflow}{else} :
00110         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(len(seq) - 1, -1, -1) :
00111             \textcolor{keywordflow}{if} seq[i] != 0 :
00112                 \textcolor{keywordflow}{break}
00113         \textcolor{keywordflow}{return} seq[:i+1]
00114 

\end{DoxyCode}


\subsection{Variable Documentation}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_a5e54a45bb5c6fa4444f663a0b0da0e1f}{\index{pyneb\-::utils\-::polyutils@{pyneb\-::utils\-::polyutils}!\-\_\-\-\_\-all\-\_\-\-\_\-@{\-\_\-\-\_\-all\-\_\-\-\_\-}}
\index{\-\_\-\-\_\-all\-\_\-\-\_\-@{\-\_\-\-\_\-all\-\_\-\-\_\-}!pyneb::utils::polyutils@{pyneb\-::utils\-::polyutils}}
\subsubsection[{\-\_\-\-\_\-all\-\_\-\-\_\-}]{\setlength{\rightskip}{0pt plus 5cm}list pyneb.\-utils.\-polyutils.\-\_\-\-\_\-all\-\_\-\-\_\-}}\label{namespacepyneb_1_1utils_1_1polyutils_a5e54a45bb5c6fa4444f663a0b0da0e1f}
{\bfseries Initial value\-:}
\begin{DoxyCode}
\hypertarget{namespacepyneb_1_1utils_1_1polyutils_l00001}{}\hyperlink{namespacepyneb_1_1utils_1_1polyutils}{00001} = [\textcolor{stringliteral}{'RankWarning'}, \textcolor{stringliteral}{'PolyError'}, \textcolor{stringliteral}{'PolyDomainError'}, \textcolor{stringliteral}{'PolyBase'},
00002            \textcolor{stringliteral}{'as\_series'}, \textcolor{stringliteral}{'trimseq'}, \textcolor{stringliteral}{'trimcoef'}, \textcolor{stringliteral}{'getdomain'}, \textcolor{stringliteral}{'mapdomain'},
00003            \textcolor{stringliteral}{'mapparms'}]
\end{DoxyCode}


Definition at line \hyperlink{polyutils_8py_source_l00036}{36} of file \hyperlink{polyutils_8py_source}{polyutils.\-py}.

